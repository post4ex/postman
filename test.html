<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uploader - Postman</title>
    <!-- Google Fonts & Tailwind CSS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Site Styles -->
    <link rel="stylesheet" href="style.css">
    <!-- Cropper.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
    <style>
        /* --- Base Uploader Styles (Original) --- */
        body { font-family: 'Inter', sans-serif; display: flex; flex-direction: column; min-height: 100vh; }
        .uploader-container button {
            padding: 8px 16px; border: 1px solid #ccc; background-color: #fff; border-radius: 4px;
            cursor: pointer; font-weight: 500; color: #333; transition: background-color 0.2s, border-color 0.2s;
        }
        .uploader-container button:hover { background-color: #f0f0f0; border-color: #bbb; }
        .uploader-container button:disabled { background-color: #e9ecef; cursor: not-allowed; opacity: 0.7; }
        .uploader-container {
            display: flex; flex-direction: column; align-items: center; gap: 15px;
            width: 100%; box-sizing: border-box;
        }
        #gscript-container {
            width: 100%; padding: 10px; background-color: #fffbe6; border-radius: 8px; border: 1px solid #ffeeba;
        }
        #gscript-container input { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
        #main-controls-strip {
            width: 100%; display: flex; justify-content: center; align-items: center;
            gap: 10px; flex-wrap: wrap; padding: 8px; background-color: #e9ecef;
            border-radius: 8px; box-sizing: border-box;
        }
        .upload-type-strip, .button-group {
            display: flex; flex-wrap: wrap; gap: 8px;
            align-items: center; justify-content: center;
        }
        .separator { width: 1px; height: 28px; background-color: #ced4da; }
        @media (max-width: 680px) { .separator { display: none; } }
        .type-btn { padding: 6px 12px; }
        .type-btn.active {
            background-color: #1E3A8A; color: #fff; border-color: #1E3A8A; font-weight: bold;
        }
        .type-btn.active:hover { background-color: #1c347a; }
        #image-scroller-container {
            width: 100%; height: 80px; background-color: #eee; border: 1px solid #ddd;
            border-radius: 4px; padding: 5px; box-sizing: border-box; display: none;
        }
        #image-scroller { height: 100%; display: flex; gap: 5px; overflow-x: auto; white-space: nowrap; }
        .scroller-img {
            height: 100%; width: 70px; object-fit: cover; cursor: pointer;
            border: 2px solid transparent; border-radius: 2px; transition: border-color 0.2s;
        }
        .scroller-img.active { border-color: #1E3A8A; }
        #image-view-area {
            border: 2px dashed #ccc; width: 100%; aspect-ratio: 4 / 3; display: flex;
            justify-content: center; align-items: center; text-align: center; color: #888;
            position: relative; overflow: hidden; background-color: #f0f0f0;
            cursor: default;
        }
        #image-view-area.selectable { cursor: crosshair; }
        #image-preview { display: none; }
        #camera-feed, #preview-canvas { width: 100%; height: 100%; object-fit: contain; }
        #camera-feed.active-capture { cursor: pointer; }
        #preview-canvas { display: none; }
        #rotate-btn, #lock-btn, #cancel-btn, #cancel-all-btn, #file-input { display: none; }
        .entry-input-group { display: flex; flex-wrap: wrap; gap: 8px; width: 100%; align-items: center; }
        .entry-input-group input, .entry-input-group select { padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; }
        .data-table-container { width: 100%; margin-top: 5px; overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; font-size: 14px; }
        th { background-color: #f0f0f0; }
        td .image-cell-content { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; }
        td .image-cell-content img { max-width: 100%; max-height: 100%; object-fit: contain; }
        #table-actions { width: 100%; margin-top: 15px; }
        #inline-cropper-wrapper {
            display: none; width: 100%; padding: 10px; box-sizing: border-box;
            background-color: #f0f0f0; border: 2px dashed #1E3A8A; 
        }
        #cropper-container { width: 100%; height: 60vh; }
        #cropper-image { display: block; max-width: 100%; }
        #selection-canvas {
            position: absolute; top: 0; left: 0; display: none; z-index: 10;
        }
        #status-bar {
            width: 100%; padding: 8px; box-sizing: border-box; min-height: 2.5em;
            text-align: center; background-color: #e9ecef; border-radius: 4px; color: #495057;
        }
        #status-bar.error { color: #dc3545; font-weight: bold; }
        .slider-control { display: flex; align-items: center; gap: 10px; width: 100%; max-width: 280px; justify-content: center; }
        .enhancement-sliders { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 15px; }
        input[type="range"] { flex-grow: 1; }
        
        /* --- MODIFIED: Original Layout Wrapper --- */
        .main-content-wrapper { 
            display: flex; 
            flex-direction: column; /* Mobile-first: stacks preview on top of controls */
            width: 100%; 
            gap: 15px; 
        }
        .preview-column, .controls-column { width: 100%; }
        .controls-column { 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            /* This column will now contain the status bar, list, inputs, and table */
        }
        /* --- This is the key change for the layout --- */
        @media (min-width: 1024px) { /* lg breakpoint */
            .main-content-wrapper { 
                flex-direction: row; /* Side-by-side on desktop */
                align-items: flex-start; 
            }
            .preview-column { 
                flex: 1.5; /* Image preview takes more space */
                min-width: 0; 
                /* Sticky positioning for the preview area */
                position: sticky;
                top: 100px; /* Adjust based on your header height */
            }
            .controls-column { 
                flex: 1; /* Controls take less space */
                min-width: 0; 
            }
            .data-table-container, #table-actions { margin-top: 0; }
        }

        /* --- NEW: Mini Order List Styles --- */
        #miniOrderListContainer {
            width: 100%; max-height: 200px; overflow-y: auto; border: 1px solid #e5e7eb;
            border-radius: 0.375rem; background-color: #f9fafb; padding: 0.5rem; margin-bottom: 0.5rem;
        }
        #miniOrderList li {
            padding: 0.25rem 0.5rem; font-size: 0.875rem; cursor: pointer; border-radius: 0.25rem; margin-bottom: 0.25rem;
            white-space: normal; line-height: 1.4; border-bottom: 1px solid #eee;
        }
         #miniOrderList li:last-child { border-bottom: none; }
        #miniOrderList li:hover { background-color: #eef2ff; }
        #miniOrderList li strong { color: #4338ca; display: block; margin-bottom: 2px; }
        #miniOrderList .client-info { font-size: 0.8rem; color: #6b7280; }
        #miniOrderList .details-info { font-size: 0.75rem; color: #4b5563; margin-top: 2px; }
        #miniOrderList .dest-info { font-size: 0.8rem; color: #374151; margin-top: 2px;}
        #loadMoreBtn {
            display: block; width: 100%; text-align: center; padding: 6px; font-size: 0.8rem;
            color: #4f46e5; background-color: #eef2ff; border: 1px solid #c7d2fe;
            border-radius: 0.375rem; margin-top: 0.5rem; margin-bottom: 1rem; cursor: pointer;
        }
         #loadMoreBtn:hover { background-color: #e0e7ff; }
         #loadMoreBtn:disabled { background-color: #f3f4f6; color: #9ca3af; cursor: not-allowed; }

    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">

    <div id="header-placeholder"></div>

    <!-- Main Content Wrapper -->
    <main class="w-full flex-grow p-4 sm:p-8">
        <div class="container mx-auto">
            <!-- This is the single card layout from the original uploader.html -->
            <div class="card">
                <div class="uploader-container">
                    
                    <!-- Google Apps Script URL Input -->
                    <div id="gscript-container" style="display: none;">
                        <label for="gscript-url"><b>Paste your Google Apps Script Web App URL here:</b></label>
                        <input type="text" id="gscript-url" placeholder="https://script.google.com/macros/s/.../exec" value="https://script.google.com/macros/s/AKfycbwkC3OXNACPPH-LLPJyhkZKaDh6VtNgGbp8lMQbzz1XF327IN_OhFEEapOzNm3REbn5/exec">
                    </div>

                    <!-- Hidden fields for selected order data -->
                    <div style="display: none;">
                        <input type="hidden" id="selectedOrderRef">
                        <input type="hidden" id="selectedOrderBranch">
                        <input type="hidden" id="selectedOrderCode">
                        <input type="hidden" id="selectedCustomerUid">
                        <input type="hidden" id="selectedDocType">
                    </div>

                    <!-- Main Controls -->
                    <div id="main-controls-strip">
                        <div class="upload-type-strip">
                            <button class="type-btn active" data-type="POD">POD</button>
                            <button class="type-btn" data-type="Reciept">Reciept</button>
                            <button class="type-btn" data-type="KYC">KYC</button>
                            <button class="type-btn" data-type="Product">Product</button>
                            <button class="type-btn" data-type="MultiBox">MultiBox</button>
                        </div>
                        <div class="separator"></div>
                        <div class="button-group">
                            <button id="camera-btn">Camera</button>
                            <button id="upload-btn">Upload</button>
                            <button id="rotate-btn">Rotate</button>
                            <button id="lock-btn">Lock</button>
                            <button id="cancel-btn">Cancel</button>
                            <button id="cancel-all-btn">Cancel All</button>
                            <input type="file" id="file-input" accept="image/*,application/pdf" multiple>
                        </div>
                    </div>

                    <!-- Image Scroller (Original) -->
                    <div id="image-scroller-container"><div id="image-scroller"></div></div>
                    
                    <!-- Main Content Wrapper (Original) -->
                    <!-- This div now controls the Left/Right split on desktop -->
                    <div class="main-content-wrapper">
                        
                        <!-- Left Column (Preview) -->
                        <div class="preview-column">
                            <!-- Inline Cropper -->
                            <div id="inline-cropper-wrapper">
                                <div id="cropper-container">
                                    <img id="cropper-image" src="">
                                </div>
                                <div class="button-group" style="margin-top: 10px;">
                                    <button id="crop-rotate-btn">Rotate</button>
                                    <button id="enhance-btn">Enhance</button>
                                    <button id="crop-confirm-btn">Crop</button>
                                    <button id="crop-cancel-btn">Cancel</button>
                                </div>
                                <div id="enhancement-controls" style="display:none; margin-top:10px; padding-top:10px; border-top: 1px solid #ccc;">
                                    <div class="button-group">
                                         <button id="auto-enhance-btn">Auto</button>
                                        <button id="greyscale-btn">Greyscale</button>
                                        <button id="bw-btn">B&W Doc</button>
                                        <button id="sharpen-btn">Sharpen</button>
                                        <button id="reset-enhance-btn" style="background-color: #f8d7da;">Reset</button>
                                    </div>
                                    <div class="enhancement-sliders">
                                        <div class="slider-control">
                                            <label for="brightness-slider">Brightness</label>
                                            <input type="range" id="brightness-slider" min="-50" max="50" value="0">
                                        </div>
                                        <div class="slider-control">
                                            <label for="contrast-slider">Contrast</label>
                                            <input type="range" id="contrast-slider" min="-50" max="50" value="0">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Preview Area -->
                            <div id="image-view-area">
                                <span id="placeholder"></span>
                                <img id="image-preview" src="" alt="Image preview"/>
                                <canvas id="preview-canvas"></canvas>
                                <canvas id="selection-canvas"></canvas>
                                <video id="camera-feed" autoplay playsinline></video>
                            </div>
                        </div>

                        <!-- Right Column (Controls) -->
                        <div class="controls-column">
                            <!-- Status Bar -->
                            <div id="status-bar">Loading App Data...</div>

                            <!-- === NEW: Mini Order List (Inserted here) === -->
                            <div id="miniOrderListContainer" class="w-full" style="display: none;"> <!-- Hidden by default until data loads -->
                                <input type="text" id="searchMiniOrder" placeholder="Filter orders..." class="w-full p-1 mb-2 border border-gray-300 rounded-md text-sm">
                                <ul id="miniOrderList">
                                    <li class="text-center text-gray-500 text-sm">Loading orders...</li>
                                </ul>
                                <button id="loadMoreBtn" style="display: none;">Load More (Older)</button>
                            </div>

                            <!-- Inputs (Original) -->
                            <div class="entry-input-group">
                                <input type="text" id="awb-input" placeholder="AWB / Ref (Required)">
                                
                                <input type="text" id="customer-name-input" placeholder="Enter Customer Name" style="display: none;" list="customer-list">
                                <datalist id="customer-list"></datalist>
                                
                                <select id="kyc-type-select" style="display: none;">
                                    <optgroup label="Individual">
                                        <option value="Aadhaar Card">Aadhaar Card</option>
                                        <option value="PAN Card">PAN Card</option>
                                        <option value="Indian Passport">Indian Passport</option>
                                        <option value="Voter ID Card">Voter ID Card</option>
                                        <option value="Driving License">Driving License</option>
                                        <option value="NREGA Job Card">NREGA Job Card</option>
                                    </optgroup>
                                    <optgroup label="Business">
                                        <option value="Partnership Deed">Partnership Deed</option>
                                        <option value="Certificate of Incorporation">Certificate of Incorporation</option>
                                        <option value="GST Registration">GST Registration</option>
                                        <option value="MoA & AoA">MoA & AoA</option>
                                        <option value="Board Resolution">Board Resolution</option>
                                    </optgroup>
                                </select>
                                <select id="doc-type-select" style="display: none;">
                                    <option value="INV">INV</option>
                                    <option value="EWB">EWB</option>
                                    <option value="CLN">CLN</option>
                                    <option value="ADH">ADH</option>
                                    <option value="DBT">DBT</option>
                                    <option value="CDT">CDT</option>
                                    <option value="HRD">HRD</option>
                                    <option value="AGT">AGT</option>
                                    <option value="INT">INT</option>
                                </select>
                                <input type="text" id="doc-number-input" placeholder="Enter Doc Number" style="display: none;" list="doc-number-list">
                                <datalist id="doc-number-list"></datalist>

                                <input type="text" id="remark-input" placeholder="Status Remark (Default: Delivered)">
                                <button id="pick-btn">Pick</button>
                            </div>
                            <!-- Table (Original) -->
                            <div class="data-table-container">
                                <table>
                                    <thead>
                                        <tr id="table-header-row"></tr>
                                    </thead>
                                    <tbody id="data-table-body"></tbody>
                                </table>
                            </div>
                            <!-- Table Actions (Original) -->
                            <div class="button-group" id="table-actions">
                                <button id="delete-last-btn">Delete Last</button>
                                <button id="clear-all-btn">Clear All</button>
                                <button id="submit-btn">Submit</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <div id="footer-placeholder"></div>

    <script src="layout.js"></script>

    <!-- Third-party libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/camanjs/4.1.2/caman.full.min.js"></script>

    <script>
        // Set up PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;

        // --- State Variables ---
        // (Original Uploader)
        let stream = null, currentRotation = 0, isImageLocked = false, cropper = null;
        let imageQueue = [], currentImageIndex = -1;
        let barcodeDetector;
        let originalCropperSrc = null;
        let isAwbLockedForProduct = false;
        let isCustomerNameLockedForKyc = false;
        const MAX_FILES = 50, MAX_ROWS = 20;
        let isSelecting = false, selectionRect = {};
        let isProcessingOCR = false;
        let selectionCtx, previewCtx;
        let currentEnhancements = { brightness: 0, contrast: 0, sharpen: false, greyscale: false, bw: false };

        // (New List)
        let allOrders = [];
        let displayedOrders = [];
        let allClientsB2B = [];
        let allClientsB2B2C = [];
        let allProducts = [];
        let currentUploadType = 'POD';
        let displayDays = 90;

        // --- UI Elements (declared) ---
        let gscriptUrlInput, cameraBtn, uploadBtn, fileInput, placeholder, imagePreview, cameraFeed;
        let previewCanvas, rotateBtn, lockBtn, cancelBtn, cancelAllBtn, pickBtn, tableBody;
        let awbInput, remarkInput, customerNameInput, kycTypeSelect, docTypeSelect, docNumberInput;
        let deleteLastBtn, clearAllBtn, submitBtn, scrollerContainer, scroller;
        let inlineCropperWrapper, imageViewArea, cropperImage, cropConfirmBtn, cropCancelBtn;
        let cropRotateBtn, selectionCanvas, statusBar, uploadTypeStrip, tableHeaderRow;
        let enhanceBtn, enhancementControls, autoEnhanceBtn, greyscaleBtn, bwBtn, sharpenBtn, resetEnhanceBtn;
        let brightnessSlider, contrastSlider;
        // (New List UI)
        let miniOrderListContainer, orderList, searchMiniOrderInput, loadMoreBtn;
        let customerDataList, docNumberDataList;
        let selectedOrderRefInput, selectedOrderBranchInput, selectedOrderCodeInput;
        let selectedCustomerUidInput, selectedDocTypeInput;
        // This is a flag to ensure we only try to load from cache once
        let hasLoadedFromCache = false;


        // --- Barcode Detector Initialization ---
        if (!('BarcodeDetector' in window)) {
            console.log('Barcode Detector is not supported by this browser.');
        } else {
            console.log('Barcode Detector supported!');
            try {
                barcodeDetector = new BarcodeDetector({
                    formats: ['code_128', 'code_39', 'ean_13', 'qr_code', 'upc_a', 'itf']
                });
            } catch (e) {
                console.error('Barcode Detector could not be instantiated.', e);
            }
        }
        
        // --- Status Update Logic ---
        function updateStatus(message, isError = false) {
            if (statusBar) {
                statusBar.textContent = message;
                statusBar.classList.toggle('error', isError);
            }
        }

        // --- Scanning Logic ---
        async function scanBarcodeFromPreview() {
            if (!barcodeDetector) {
                updateStatus("Barcode detection not supported. Select area for OCR.", true);
                return;
            }
            if (!imagePreview.src || !imagePreview.src.startsWith('data:')) return;

            try {
                updateStatus("Attempting barcode scan...");
                const barcodes = await barcodeDetector.detect(imagePreview);
                if (barcodes.length > 0) {
                    const barcodeValue = barcodes[0].rawValue;
                    if (currentUploadType === 'MultiBox' && awbInput.disabled) {
                        remarkInput.value = barcodeValue;
                    } else if (currentUploadType === 'Product') {
                        docNumberInput.value = barcodeValue;
                    } else {
                        awbInput.value = barcodeValue;
                    }
                    updateStatus(`Barcode detected: ${barcodeValue}`);
                } else {
                    updateStatus("No barcode found. Please select an area for OCR.");
                }
            } catch (err) {
                console.error("Barcode scan failed:", err);
                updateStatus("Barcode scan failed. Select area for OCR.", true);
            }
        }

        // --- Image Compression Logic ---
        async function compressImage(dataUrl, targetSizeKB, maxDimension) {
            const targetSizeBytes = targetSizeKB * 1024;
            const img = await new Promise(resolve => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.src = dataUrl;
            });
            let { width, height } = img;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            if (width > maxDimension || height > maxDimension) {
                if (width > height) {
                    height = Math.round(height * (maxDimension / width));
                    width = maxDimension;
                } else {
                    width = Math.round(width * (maxDimension / height));
                    height = maxDimension;
                }
            }
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            let quality = 0.95;
            let compressedDataUrl;
            let sizeInBytes;
            do {
                compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                sizeInBytes = atob(compressedDataUrl.split(',')[1]).length;
                if (sizeInBytes > targetSizeBytes && quality > 0.1) {
                    quality -= 0.05;
                }
            } while (sizeInBytes > targetSizeBytes && quality > 0.1);
            console.log(`Image compressed to ${(sizeInBytes / 1024).toFixed(2)} KB.`);
            return compressedDataUrl;
        }


        // --- Main App Logic (Original) ---
        function setInterfaceState(state) {
            cameraBtn.style.display = 'inline-block';
            uploadBtn.style.display = 'inline-block';
            uploadTypeStrip.style.display = 'flex';
            rotateBtn.style.display = 'none';
            lockBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
            cancelAllBtn.style.display = 'none';
            imageViewArea.classList.remove('selectable');
            cameraFeed.classList.remove('active-capture');

            if (state === 'streaming') {
                cameraBtn.textContent = 'Capture';
                uploadBtn.style.display = 'none';
                cancelBtn.style.display = 'inline-block';
                previewCanvas.style.display = 'none';
                cameraFeed.style.display = 'block';
                cameraFeed.classList.add('active-capture');
                uploadTypeStrip.style.display = 'none';
            } else if (state === 'preview') {
                cameraBtn.style.display = 'none';
                uploadBtn.style.display = 'none';
                rotateBtn.style.display = 'inline-block';
                lockBtn.style.display = 'inline-block';
                imageViewArea.classList.add('selectable');
                uploadTypeStrip.style.display = 'none';
                if (imageQueue.length > 0) {
                    cancelBtn.style.display = 'inline-block';
                    cancelAllBtn.style.display = 'inline-block';
                } else {
                    cancelBtn.style.display = 'inline-block';
                }
            }
        }


        function resetUploader() {
            stopCamera();
            placeholder.style.display = 'block';
            previewCanvas.style.display = 'none';
            cameraFeed.style.display = 'none'; 
            imagePreview.src = '';
            fileInput.value = ''; currentRotation = 0;
            isImageLocked = false; lockBtn.textContent = 'Lock'; lockBtn.style.backgroundColor = '';
            imageQueue = []; currentImageIndex = -1;
            scroller.innerHTML = ''; scrollerContainer.style.display = 'none';
            inlineCropperWrapper.style.display = 'none';
            imageViewArea.style.display = 'flex';
            selectionCanvas.style.display = 'none';
            updateStatus('Select an order or start capture');
            isAwbLockedForProduct = false;
            awbInput.disabled = false;
            isCustomerNameLockedForKyc = false;
            customerNameInput.disabled = false;
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.backgroundColor = '';
            cancelBtn.style.borderColor = '';
            cancelBtn.style.color = '';
            setInterfaceState('idle');
        }

        function stopCamera() { 
            if (stream) { 
                stream.getTracks().forEach(track => track.stop()); 
                stream = null; 
            }
            if (cameraFeed) {
                cameraFeed.removeEventListener('click', handleVideoStreamClick);
            }
        }

        function displayImage(index) {
            if (index < 0 || index >= imageQueue.length) { resetUploader(); return; }
            currentImageIndex = index;
            const file = imageQueue[index];
            const reader = new FileReader();
            reader.onload = (e) => initCropper(e.target.result, file.name);
            reader.readAsDataURL(file);
        }

        function renderScroller() {
            scroller.innerHTML = '';
            imageQueue.forEach((file, index) => {
                const thumb = document.createElement('img');
                try { thumb.src = URL.createObjectURL(file); } catch(e) { console.error("Could not create object URL for", file); }
                thumb.className = 'scroller-img'; thumb.dataset.index = index;
                thumb.onclick = () => displayImage(index);
                scroller.appendChild(thumb);
            });
            updateActiveThumbnail();
        }

        function updateActiveThumbnail() {
            document.querySelectorAll('.scroller-img').forEach((img, index) => {
                img.classList.toggle('active', index === currentImageIndex);
            });
        }
        
        // --- Cropper Logic (Original) ---
        function initCropper(imageSrc, originalFileName) {
            originalCropperSrc = imageSrc;
            currentEnhancements = { brightness: 0, contrast: 0, sharpen: false, greyscale: false, bw: false };
            if (brightnessSlider) brightnessSlider.value = 0;
            if (contrastSlider) contrastSlider.value = 0;
            if (sharpenBtn) sharpenBtn.style.backgroundColor = '';
            if (greyscaleBtn) greyscaleBtn.style.backgroundColor = '';
            if (bwBtn) bwBtn.style.backgroundColor = '';
            if (enhancementControls) enhancementControls.style.display = 'none';
            inlineCropperWrapper.style.display = 'block';
            imageViewArea.style.display = 'none';
            scrollerContainer.style.display = 'none'; 
            cropperImage.src = imageSrc;
            if (cropper) cropper.destroy();
            cropper = new Cropper(cropperImage, {
                viewMode: 1,
                background: false,
            });
            
            const confirmCropHandler = async () => {
                const croppedCanvas = cropper.getCroppedCanvas({
                    minWidth: 256, minHeight: 256, maxWidth: 4096, maxHeight: 4096,
                    fillColor: '#fff', imageSmoothingEnabled: true, imageSmoothingQuality: 'high',
                });
                if (!croppedCanvas) { return; }
                let croppedDataUrl = croppedCanvas.toDataURL('image/png');
                inlineCropperWrapper.style.display = 'none';
                imageViewArea.style.display = 'flex';
                if (imageQueue.length > 1) scrollerContainer.style.display = 'block';
                imagePreview.onload = () => {
                    drawPreview();
                    scanBarcodeFromPreview();
                    imagePreview.onload = null;
                };
                imagePreview.src = croppedDataUrl; 
                placeholder.style.display = 'none';
                cameraFeed.style.display = 'none';
                previewCanvas.style.display = 'block';
                currentRotation = 0;
                if (currentImageIndex !== -1) {
                    const newFile = await dataURLtoFile(croppedDataUrl, originalFileName.replace(/\.\w+$/, '.png'));
                    imageQueue[currentImageIndex] = newFile;
                    renderScroller();
                }
                setInterfaceState('preview');
                cropConfirmBtn.removeEventListener('click', confirmCropHandler);
            };
            cropConfirmBtn.addEventListener('click', confirmCropHandler, { once: true });
        }
        
        // --- NEW: Data Loading from appData ---
        // This is now called by the event listener OR the cache check
        const initializeOrderData = (event) => {
            console.log("DEBUG: initializeOrderData triggered");
            
            // Prevent multiple loads
            if (hasLoadedFromCache && event.type === 'appDataLoaded') {
                console.log("DEBUG: Data already loaded from cache, ignoring appDataLoaded event.");
                return;
            }
            if (hasLoadedFromCache && event.type === 'appDataRefreshed') {
                 console.log("DEBUG: Refreshing data from appDataRefreshed event.");
                 // Allow refresh to proceed
            }
            
            if (!event || !event.detail || !event.detail.data) {
                console.error("DEBUG: Invalid event passed to initializeOrderData:", event);
                updateStatus('No app data loaded.', true);
                return;
            };

            const data = event.detail.data;
            console.log("DEBUG: Data received from appData:", data);

            allOrders = Array.isArray(data.ORDERS) ? data.ORDERS : [];
            allOrders = allOrders
                .filter(order => order && order.ORDER_DATE)
                .sort((a, b) => {
                    try {
                        const dateA = new Date(a.ORDER_DATE);
                        const dateB = new Date(b.ORDER_DATE);
                        if (isNaN(dateA.getTime())) return 1;
                        if (isNaN(dateB.getTime())) return -1;
                        return dateB - dateA;
                    } catch (e) {
                         return 0;
                    }
                });
            console.log("DEBUG: Sorted allOrders count:", allOrders.length);

            allClientsB2B = Array.isArray(data.B2B) ? data.B2B : [];
            allClientsB2B2C = Array.isArray(data.B2B2C) ? data.B2B2C : [];
            allProducts = Array.isArray(data.PRODUCT) ? data.PRODUCT : [];
            console.log("DEBUG: B2B:", allClientsB2B.length, "B2B2C:", allClientsB2B2C.length, "Products:", allProducts.length);

            displayDays = 90; // Default load
            filterAndRenderOrders();
            updateUIForUploadType(currentUploadType);
            updateStatus("App data loaded. Select an order or start capture.");
            miniOrderListContainer.style.display = 'block'; // Show the list
            hasLoadedFromCache = true; // Mark as loaded
        };

        // --- NEW: Date Formatting Helper ---
        function formatDate(dateString) {
             if (!dateString) return 'N/A';
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) {
                     return 'Invalid Date';
                }
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            } catch (e) {
                return 'Invalid Date';
            }
        }

        // --- NEW: List Rendering ---
        const renderMiniOrderList = (ordersToRender) => {
            if (!miniOrderList) return;
            miniOrderList.innerHTML = '';
             displayedOrders = ordersToRender;

            if (!ordersToRender || ordersToRender.length === 0) {
                miniOrderList.innerHTML = '<li class="text-center text-gray-500 text-sm">No matching orders found.</li>';
                if(loadMoreBtn) loadMoreBtn.style.display = 'none';
                return;
            }

            ordersToRender.forEach((order) => {
                const ref = order.REFERANCE;
                 if (!ref) return;

                const displayAwb = order.AWB_NUMBER || ref;
                const consignorClient = allClientsB2B2C.find(c => c.UID === order.CONSIGNOR);
                const consignorName = consignorClient ? (consignorClient.NAME || 'Unknown') : 'Unknown';
                const consigneeClient = allClientsB2B2C.find(c => c.UID === order.CONSIGNEE);
                const consigneeName = consigneeClient ? (consigneeClient.NAME || 'Unknown') : 'Unknown';
                const destination = order.DEST_CITY || 'N/A';
                const orderDate = formatDate(order.ORDER_DATE);
                const value = order.VALUE || 0;
                const pieces = order.PIECS || 0;

                const li = document.createElement('li');
                li.innerHTML = `<strong>${displayAwb}</strong>
                                <div class="client-info">${consignorName} -> ${consigneeName}</div>
                                <div class="details-info">Date: ${orderDate} | Value: ${value} | Pcs: ${pieces}</div>
                                <div class="dest-info">Dest: ${destination}</div>`;
                li.dataset.orderRef = ref;
                li.addEventListener('click', () => selectOrderForInputs(ref));
                miniOrderList.appendChild(li);
            });

            const searchTerm = searchMiniOrderInput ? searchMiniOrderInput.value.toLowerCase() : "";
            const totalFilteredCount = filterOrdersBySearchTerm(searchTerm).length;
            
            if (ordersToRender.length < totalFilteredCount) {
                 if(loadMoreBtn) {
                    loadMoreBtn.style.display = 'block';
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.textContent = `Load More (${ordersToRender.length} / ${totalFilteredCount})`;
                 }
            } else {
                 if(loadMoreBtn) loadMoreBtn.style.display = 'none';
            }
        };

        // --- NEW: Selection Handling ---
        const selectOrderForInputs = (orderRef) => {
            const order = allOrders.find(o => o.REFERANCE === orderRef);
            if (!order) return;

            // Store hidden data
            selectedOrderRefInput.value = order.REFERANCE || '';
            selectedOrderBranchInput.value = order.BRANCH || '';
            selectedOrderCodeInput.value = order.CODE || '';
            console.log("Stored Hidden Order Data:", { ref: order.REFERANCE, branch: order.BRANCH, code: order.CODE });

            const displayValue = order.AWB_NUMBER || order.REFERANCE || 'N/A';

            if (currentUploadType === 'KYC') {
                awbInput.value = '';
                awbInput.placeholder = "Enter KYC Number (Required)";
            } else {
                awbInput.value = displayValue;
                 updateUIForUploadType(currentUploadType);
            }

            customerNameInput.value = '';
            docNumberInput.value = '';
            remarkInput.value = '';
            selectedCustomerUidInput.value = '';
            selectedDocTypeInput.value = '';

            populateKycData(order);
            populateProductData(order);

            updateStatus(`Selected Order: ${displayValue}. Datalists populated.`);
            console.log("Selected Order Object:", order);
            
            if (currentUploadType === 'KYC') {
                awbInput.focus();
            } else if (currentUploadType === 'Product') {
                docNumberInput.focus();
            } else {
                 awbInput.focus();
            }
        };

        // --- NEW: Datalist Population Functions ---
        const populateKycData = (order) => {
            if(!customerDataList) return;
            customerDataList.innerHTML = '';
            const clientCode = order.CODE;
            const consignorUID = order.CONSIGNOR;
            const consigneeUID = order.CONSIGNEE;

             if (consignorUID) {
                 const consignorClient = allClientsB2B2C.find(c => c.UID === consignorUID);
                 if (consignorClient && consignorClient.NAME) {
                     const option = document.createElement('option');
                     option.value = consignorClient.NAME;
                     customerDataList.appendChild(option);
                 }
            }
            if (consigneeUID) {
                 const consigneeClient = allClientsB2B2C.find(c => c.UID === consigneeUID);
                 if (consigneeClient && consigneeClient.NAME) {
                     const exists = Array.from(customerDataList.options).some(opt => opt.value === consigneeClient.NAME);
                     if (!exists) {
                         const option = document.createElement('option');
                         option.value = consigneeClient.NAME;
                         customerDataList.appendChild(option);
                     }
                 }
            }
             if (clientCode) {
                 const parentClient = allClientsB2B.find(c => c.CODE === clientCode);
                 if (parentClient && parentClient.CLIENT_NAME) {
                     const exists = Array.from(customerDataList.options).some(opt => opt.value === parentClient.CLIENT_NAME);
                     if (!exists) {
                         const option = document.createElement('option');
                         option.value = parentClient.CLIENT_NAME;
                         customerDataList.appendChild(option);
                     }
                 }
            }
        };
        
        const populateProductData = (order) => {
            if(!docNumberDataList) return;
            docNumberDataList.innerHTML = '';
            const orderRef = order.REFERANCE;
            if (!orderRef || !allProducts) return;

            const productsForOrder = allProducts.filter(p => p.RERERANCE === orderRef);

            productsForOrder.forEach(product => {
                if (product.DOC_NUMBER) {
                    const option = document.createElement('option');
                    option.value = `Doc: ${product.DOC_NUMBER}, Type: ${product.TYPE}, Amount: ${product.AMOUNT}`;
                    option.dataset.docNumber = product.DOC_NUMBER;
                    option.dataset.docType = product.TYPE;
                    docNumberDataList.appendChild(option);
                }
                if (product.EWAY_IF && String(product.EWAY_IF).trim() !== "") {
                    const option = document.createElement('option');
                    option.value = `Eway: ${product.EWAY_IF}, Type: EWB, Amount: ${product.AMOUNT}`;
                    option.dataset.docNumber = product.EWAY_IF;
                    option.dataset.docType = 'EWB';
                }
            });
        };

        // --- NEW: Filtering Logic ---
        function filterOrdersBySearchTerm(searchTerm) {
             if (!Array.isArray(allOrders)) return [];
             if (!searchTerm) return allOrders;
             
             return allOrders.filter(order => {
                const consignorClient = allClientsB2B2C.find(c => c.UID === order.CONSIGNOR);
                const consignorName = consignorClient ? (consignorClient.NAME || '') : '';
                const consigneeClient = allClientsB2B2C.find(c => c.UID === order.CONSIGNEE);
                const consigneeName = consigneeClient ? (consigneeClient.NAME || '') : '';
                const destination = order.DEST_CITY || '';
                const orderDateStr = formatDate(order.ORDER_DATE).toLowerCase();

                 return (order.REFERANCE ? String(order.REFERANCE).toLowerCase().includes(searchTerm) : false) ||
                        (order.AWB_NUMBER ? String(order.AWB_NUMBER).toLowerCase().includes(searchTerm) : false) ||
                        (consignorName ? consignorName.toLowerCase().includes(searchTerm) : false) ||
                        (consigneeName ? consigneeName.toLowerCase().includes(searchTerm) : false) ||
                        (destination ? destination.toLowerCase().includes(searchTerm) : false) ||
                        (orderDateStr ? orderDateStr.includes(searchTerm) : false);
             });
        }
        
        function filterOrdersByDate(orders) {
             const cutoffDate = new Date();
             cutoffDate.setDate(cutoffDate.getDate() - displayDays);
             cutoffDate.setHours(0, 0, 0, 0);
             if (!Array.isArray(orders)) return [];
             return orders.filter(order => {
                 const orderDate = order.ORDER_DATE ? new Date(order.ORDER_DATE) : null;
                 return orderDate && orderDate >= cutoffDate;
             });
        }

        function filterAndRenderOrders() {
            const searchTerm = searchMiniOrderInput ? searchMiniOrderInput.value.toLowerCase() : "";
            let searchFilteredOrders = filterOrdersBySearchTerm(searchTerm);
            if (!Array.isArray(searchFilteredOrders)) searchFilteredOrders = [];
            const dateFilteredOrders = filterOrdersByDate(searchFilteredOrders);
            renderMiniOrderList(dateFilteredOrders);
        }

        // --- Original drawPreview and OCR logic ---
        function drawPreview() {
            if (!imagePreview.src || !imageViewArea) return;
            const dpr = window.devicePixelRatio || 1;
            const containerW = imageViewArea.clientWidth;
            const containerH = imageViewArea.clientHeight;
            if (!containerW || !containerH) return;
            
            previewCanvas.width = containerW * dpr;
            previewCanvas.height = containerH * dpr;
            previewCanvas.style.width = `${containerW}px`;
            previewCanvas.style.height = `${containerH}px`;
            
            previewCtx.scale(dpr, dpr);
            
            const naturalW = imagePreview.naturalWidth;
            const naturalH = imagePreview.naturalHeight;
            const imgAspect = naturalW / naturalH;
            const contAspect = containerW / containerH;
            let renderedW, renderedH;

            if (imgAspect > contAspect) {
                renderedW = containerW; renderedH = containerW / imgAspect;
            } else {
                renderedH = containerH; renderedW = containerH * imgAspect;
            }
            
            previewCtx.clearRect(0, 0, containerW, containerH);
            previewCtx.save();
            previewCtx.translate(containerW / 2, containerH / 2);
            previewCtx.rotate(currentRotation * Math.PI / 180);
            previewCtx.drawImage(imagePreview, -renderedW / 2, -renderedH / 2, renderedW, renderedH);
            previewCtx.restore();
        }

        function onSelectionStart(e) {
            if (previewCanvas.style.display !== 'block' || isSelecting || isProcessingOCR) return;
            e.preventDefault();
            
            const rect = imageViewArea.getBoundingClientRect();
            selectionCanvas.width = rect.width;
            selectionCanvas.height = rect.height;
            selectionCanvas.style.display = 'block';

            isSelecting = true;
            const point = e.touches ? e.touches[0] : e;
            selectionRect.startX = point.clientX - rect.left;
            selectionRect.startY = point.clientY - rect.top;

            window.addEventListener('mousemove', onSelectionMove);
            window.addEventListener('touchmove', onSelectionMove, { passive: false });
            window.addEventListener('mouseup', onSelectionUp, { once: true });
            window.addEventListener('touchend', onSelectionUp, { once: true });
        }

        function onSelectionMove(e) {
            if (!isSelecting) return;
            e.preventDefault();
            const rect = imageViewArea.getBoundingClientRect();
            const point = e.touches ? e.touches[0] : e;
            const currentX = point.clientX - rect.left;
            const currentY = point.clientY - rect.top;
            const width = currentX - selectionRect.startX;
            const height = currentY - selectionRect.startY;

            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            selectionCtx.strokeStyle = 'red';
            selectionCtx.lineWidth = 2;
            selectionCtx.strokeRect(selectionRect.startX, selectionRect.startY, width, height);
        }

        async function onSelectionUp(e) {
            if (!isSelecting) return;
            isSelecting = false;
            window.removeEventListener('mousemove', onSelectionMove);
            window.removeEventListener('touchmove', onSelectionMove);
            
            selectionCanvas.style.display = 'none';
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            
            const rect = imageViewArea.getBoundingClientRect();
            const point = e.changedTouches ? e.changedTouches[0] : e;
            const selectionEndX = point.clientX - rect.left;
            const selectionEndY = point.clientY - rect.top;

            const selX = Math.min(selectionRect.startX, selectionEndX);
            const selY = Math.min(selectionRect.startY, selectionEndY);
            const selW = Math.abs(selectionRect.startX - selectionEndX);
            const selH = Math.abs(selectionRect.startY - selectionEndY);

            if (selW < 10 || selH < 10) return;

            const naturalW = imagePreview.naturalWidth;
            const naturalH = imagePreview.naturalHeight;
            const containerW = imageViewArea.clientWidth;
            const containerH = imageViewArea.clientHeight;
            const imgAspect = naturalW / naturalH;
            const contAspect = containerW / containerH;
            let renderedW, renderedH;

            if (imgAspect > contAspect) {
                renderedW = containerW; renderedH = containerW / imgAspect;
            } else {
                renderedH = containerH; renderedW = containerH * imgAspect;
            }

            const offsetX = (containerW - renderedW) / 2;
            const offsetY = (containerH - renderedH) / 2;
            const scaleFactor = naturalW / renderedW;
            const sourceX = (selX - offsetX) * scaleFactor;
            const sourceY = (selY - offsetY) * scaleFactor;
            const sourceWidth = selW * scaleFactor;
            const sourceHeight = selH * scaleFactor;
            
            if (sourceX < 0 || sourceY < 0 || sourceX + sourceWidth > naturalW || sourceY + sourceHeight > naturalH) {
                updateStatus("Selection was outside the image area.", true);
                isProcessingOCR = false; 
                return;
            }

            const cropCanvas = document.createElement('canvas');
            const cropCtx = cropCanvas.getContext('2d');
            cropCanvas.width = sourceWidth;
            cropCanvas.height = sourceHeight;
            cropCtx.drawImage(imagePreview, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);

            isProcessingOCR = true;
            updateStatus("Running OCR on selected area...");
            try {
                const { data: { text } } = await Tesseract.recognize(cropCanvas, 'eng');
                const ocrText = text.trim().replace(/\s+/g, '');
                if (ocrText) {
                    if (currentUploadType === 'MultiBox' && awbInput.disabled) {
                        remarkInput.value = ocrText;
                    } else if (currentUploadType === 'Product') {
                        docNumberInput.value = ocrText;
                    } else {
                        awbInput.value = ocrText;
                    }
                    updateStatus(`OCR successful: "${ocrText}"`);
                } else {
                    updateStatus("OCR could not find any text in the selected area.");
                }
            } catch (err) {
                updateStatus("OCR failed on selection.", true);
            } finally {
                setTimeout(() => { isProcessingOCR = false; }, 300);
            }
        }
        
        async function handleVideoStreamClick() {
            if (!stream) return;
            if (imageQueue.length >= MAX_FILES) {
                updateStatus(`Maximum of ${MAX_FILES} images reached.`, true);
                return;
            }
            const canvas = document.createElement('canvas');
            canvas.width = cameraFeed.videoWidth;
            canvas.height = cameraFeed.videoHeight;
            canvas.getContext('2d').drawImage(cameraFeed, 0, 0);
            const dataUrl = canvas.toDataURL('image/png');
            const newFile = await dataURLtoFile(dataUrl, `capture-${Date.now()}.png`);
            imageQueue.push(newFile);
            scrollerContainer.style.display = 'block';
            renderScroller();
            updateStatus(`${imageQueue.length} image(s) captured.`);
            if (cancelBtn.textContent !== 'Done') {
                cancelBtn.textContent = 'Done';
                cancelBtn.style.backgroundColor = '#28a745';
                cancelBtn.style.borderColor = '#28a745';
                cancelBtn.style.color = 'white';
            }
        }

        function getDefaultRemark(uploadType) {
            switch (uploadType) {
                case 'Reciept': return 'Booked';
                default: return 'Delivered';
            }
        }
        
        function isDuplicateEntry() {
            const rows = tableBody.rows;
            const awbValue = awbInput.value.trim();
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                switch (currentUploadType) {
                    case 'POD':
                    case 'Reciept':
                        if (row.cells[1].textContent === awbValue) {
                            updateStatus(`Duplicate AWB / Ref found: ${awbValue}`, true);
                            awbInput.focus();
                            return true;
                        }
                        break;
                    case 'KYC':
                         if (row.cells[1].textContent === awbValue) {
                            updateStatus(`Duplicate KYC Number found: ${awbValue}`, true);
                            awbInput.focus();
                            return true;
                        }
                        break;
                    case 'Product':
                        const docNumber = docNumberInput.value.trim();
                        if (docNumber && row.cells[3].textContent === docNumber) {
                            updateStatus(`Duplicate Doc Number found: ${docNumber}`, true);
                            docNumberInput.focus();
                            return true;
                        }
                        break;
                    case 'MultiBox':
                        const childAwb = remarkInput.value.trim();
                        if (childAwb && childAwb !== awbValue && row.cells[2].textContent === childAwb) {
                             updateStatus(`Duplicate Child Awb found: ${childAwb}`, true);
                             remarkInput.focus();
                             return true;
                        }
                        break;
                }
            }
            return false;
        }

        async function dataURLtoFile(dataUrl, fileName) {
            const res = await fetch(dataUrl); const blob = await res.blob();
            return new File([blob], fileName, { type: 'image/jpeg' });
        }
        
        function getRotatedImage(src, rotation) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'), angle = rotation * Math.PI / 180;
                    if (rotation % 180 !== 0) { canvas.width = img.height; canvas.height = img.width; } 
                    else { canvas.width = img.width; canvas.height = img.height; }
                    ctx.translate(canvas.width / 2, canvas.height / 2); ctx.rotate(angle);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    resolve(canvas.toDataURL('image/png'));
                };
                img.src = src;
            });
        }
        
        // --- Image Enhancement Logic (Original) ---
        function resetEnhancements() { /* ... */ }
        let applyEnhancements = () => {}; // Declare here
        
        // --- UI Update Logic (Original) ---
        function updateTableHeader(uploadType) {
            if (!tableHeaderRow) return;
            tableHeaderRow.innerHTML = '';
            let headers = [];
            if (uploadType === 'KYC') {
                headers = ['Sl No', 'KYC Number', 'Customer Name', 'KYC Type', 'Type', 'Image'];
            } else if (uploadType === 'Product') {
                headers = ['Sl No', 'AWB / Ref', 'Doc Type', 'Doc Number', 'Type', 'Image'];
            } else if (uploadType === 'MultiBox') {
                headers = ['Sl No', 'AWB / Ref', 'Child Awb', 'Type', 'Image'];
            } else {
                headers = ['Sl No', 'AWB / Ref', 'Status Remark', 'Type', 'Image'];
            }
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                tableHeaderRow.appendChild(th);
            });
        }

        function updateUIForUploadType(uploadType) {
            if (!customerNameInput || !kycTypeSelect || !docTypeSelect || !docNumberInput || !remarkInput || !awbInput) {
                return;
            }
            
            customerNameInput.style.display = 'none';
            kycTypeSelect.style.display = 'none';
            docTypeSelect.style.display = 'none';
            docNumberInput.style.display = 'none';
            remarkInput.style.display = 'inline-block';
            awbInput.placeholder = "AWB / Ref (Required)";

            if (uploadType === 'KYC') {
                awbInput.placeholder = "Enter KYC Number (Required)";
                remarkInput.style.display = 'none';
                kycTypeSelect.style.display = 'inline-block';
                customerNameInput.style.display = 'inline-block';
            } else if (uploadType === 'Reciept') {
                remarkInput.placeholder = "Status Remark (Default: Booked)";
            } else if (uploadType === 'MultiBox') {
                remarkInput.placeholder = "Child Awb";
            } else if (uploadType === 'Product') {
                docNumberInput.placeholder = "Scan/Enter Doc Number";
                docTypeSelect.style.display = 'inline-block';
                docNumberInput.style.display = 'inline-block';
                remarkInput.style.display = 'none';
            } else { // POD (Default)
                remarkInput.placeholder = "Status Remark (Default: Delivered)";
            }
            
            updateTableHeader(uploadType);
        }

        // --- Main DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => {
             console.log("DEBUG: DOMContentLoaded fired.");
             
             // --- Assign all UI elements ---
             gscriptUrlInput = document.getElementById('gscript-url');
             cameraBtn = document.getElementById('camera-btn');
             uploadBtn = document.getElementById('upload-btn');
             fileInput = document.getElementById('file-input');
             placeholder = document.getElementById('placeholder');
             imagePreview = document.getElementById('image-preview');
             cameraFeed = document.getElementById('camera-feed');
             previewCanvas = document.getElementById('preview-canvas');
             rotateBtn = document.getElementById('rotate-btn');
             lockBtn = document.getElementById('lock-btn');
             cancelBtn = document.getElementById('cancel-btn');
             cancelAllBtn = document.getElementById('cancel-all-btn');
             pickBtn = document.getElementById('pick-btn');
             tableBody = document.getElementById('data-table-body');
             awbInput = document.getElementById('awb-input');
             remarkInput = document.getElementById('remark-input');
             customerNameInput = document.getElementById('customer-name-input');
             kycTypeSelect = document.getElementById('kyc-type-select');
             docTypeSelect = document.getElementById('doc-type-select');
             docNumberInput = document.getElementById('doc-number-input');
             deleteLastBtn = document.getElementById('delete-last-btn');
             clearAllBtn = document.getElementById('clear-all-btn');
             submitBtn = document.getElementById('submit-btn');
             scrollerContainer = document.getElementById('image-scroller-container');
             scroller = document.getElementById('image-scroller');
             inlineCropperWrapper = document.getElementById('inline-cropper-wrapper');
             imageViewArea = document.getElementById('image-view-area');
             cropperImage = document.getElementById('cropper-image');
             cropConfirmBtn = document.getElementById('crop-confirm-btn');
             cropCancelBtn = document.getElementById('crop-cancel-btn');
             cropRotateBtn = document.getElementById('crop-rotate-btn');
             selectionCanvas = document.getElementById('selection-canvas');
             statusBar = document.getElementById('status-bar');
             uploadTypeStrip = document.querySelector('.upload-type-strip');
             tableHeaderRow = document.getElementById('table-header-row');
             enhanceBtn = document.getElementById('enhance-btn');
             enhancementControls = document.getElementById('enhancement-controls');
             autoEnhanceBtn = document.getElementById('auto-enhance-btn');
             greyscaleBtn = document.getElementById('greyscale-btn');
             bwBtn = document.getElementById('bw-btn');
             sharpenBtn = document.getElementById('sharpen-btn');
             resetEnhanceBtn = document.getElementById('reset-enhance-btn');
             brightnessSlider = document.getElementById('brightness-slider');
             contrastSlider = document.getElementById('contrast-slider');
             
             // (New List UI)
             miniOrderListContainer = document.getElementById('miniOrderListContainer');
             orderList = document.getElementById('miniOrderList');
             searchMiniOrderInput = document.getElementById('searchMiniOrder');
             loadMoreBtn = document.getElementById('loadMoreBtn');

             // Datalists
             customerDataList = document.getElementById('customer-list');
             docNumberDataList = document.getElementById('doc-number-list');
             
             // Hidden Fields
             selectedOrderRefInput = document.getElementById('selectedOrderRef');
             selectedOrderBranchInput = document.getElementById('selectedOrderBranch');
             selectedOrderCodeInput = document.getElementById('selectedOrderCode');
             selectedCustomerUidInput = document.getElementById('selectedCustomerUid');
             selectedDocTypeInput = document.getElementById('selectedDocType');

             // Assign canvas contexts
             selectionCtx = selectionCanvas.getContext('2d');
             previewCtx = previewCanvas.getContext('2d');
             
             console.log("DEBUG: All UI Elements assigned.");

             // --- Add all event listeners ---
             
             // NEW: List/Form Listeners
             window.addEventListener('appDataLoaded', initializeOrderData);
             window.addEventListener('appDataRefreshed', initializeOrderData);
             
             searchMiniOrderInput.addEventListener('input', filterAndRenderOrders);
             
             loadMoreBtn.addEventListener('click', () => {
                console.log("DEBUG: Load More clicked. Current displayDays:", displayDays);
                displayDays += 7;
                console.log("DEBUG: New displayDays:", displayDays);
                filterAndRenderOrders();
             });

             // MERGED: Upload Type Listener
             uploadTypeStrip.addEventListener('click', (e) => {
                if (e.target.classList.contains('type-btn')) {
                    const selectedType = e.target.dataset.type;
                    if (selectedType === currentUploadType) return;
                    const currentActive = uploadTypeStrip.querySelector('.active');
                    if (currentActive) currentActive.classList.remove('active');
                    e.target.classList.add('active');
                    currentUploadType = selectedType;
                    updateUIForUploadType(currentUploadType);

                    const currentOrderRefVal = selectedOrderRefInput.value;
                    if (currentOrderRefVal) {
                        const order = allOrders.find(o => String(o.REFERANCE) === currentOrderRefVal);
                        if (order) {
                            if (currentUploadType !== 'KYC') {
                                awbInput.value = order.AWB_NUMBER || order.REFERANCE || '';
                            } else {
                                awbInput.value = '';
                            }
                        }
                    } else {
                         if (currentUploadType === 'KYC') {
                             awbInput.value = '';
                         }
                    }
                }
             });

             // NEW: Datalist Input Listeners
             customerNameInput.addEventListener('input', (e) => {
                const enteredName = e.target.value;
                selectedCustomerUidInput.value = '';
                const option = Array.from(customerDataList.options).find(opt => opt.value === enteredName);
                if (option) {
                    const clientB2B2C = allClientsB2B2C.find(c => c.NAME === enteredName);
                    if (clientB2B2C) {
                        selectedCustomerUidInput.value = clientB2B2C.UID;
                         console.log("Selected Customer (B2B2C):", { name: enteredName, uid: clientB2B2C.UID });
                    } else {
                        const clientB2B = allClientsB2B.find(c => c.CLIENT_NAME === enteredName);
                        if (clientB2B) {
                            selectedCustomerUidInput.value = clientB2B.CODE;
                            console.log("Selected Customer (B2B Fallback):", { name: enteredName, code: clientB2B.CODE });
                        }
                    }
                }
             });
             
             docNumberInput.addEventListener('input', (e) => {
                const enteredValue = e.target.value;
                selectedDocTypeInput.value = '';
                const option = Array.from(docNumberDataList.options).find(opt => opt.value === enteredValue);
                if (option) {
                    const actualDocNumber = option.dataset.docNumber;
                    const actualDocType = option.dataset.docType;
                    selectedDocTypeInput.value = actualDocType;
                    docTypeSelect.value = actualDocType;
                    setTimeout(() => { docNumberInput.value = actualDocNumber; }, 0);
                    console.log("Selected Doc from List:", { number: actualDocNumber, type: actualDocType });
                } else {
                    const currentOrderRef = selectedOrderRefInput.value ? parseInt(selectedOrderRefInput.value, 10) : null;
                    if (!currentOrderRef) return;
                    const product = allProducts.find(p => 
                        p.RERERANCE === currentOrderRef && 
                        (String(p.DOC_NUMBER) === enteredValue || String(p.EWAY_IF) === enteredValue)
                    );
                    if (product) {
                        let docType = (String(product.DOC_NUMBER) === enteredValue) ? product.TYPE : "EWB";
                        selectedDocTypeInput.value = docType;
                        docTypeSelect.value = docType;
                        console.log("Matched Doc by typing:", { number: enteredValue, type: docType });
                    }
                }
             });

            // --- Original Scanner Event Listeners ---
            cameraBtn.addEventListener('click', async () => {
                if (stream) {
                    const canvas = document.createElement('canvas');
                    canvas.width = cameraFeed.videoWidth;
                    canvas.height = cameraFeed.videoHeight;
                    canvas.getContext('2d').drawImage(cameraFeed, 0, 0);
                    const dataUrl = canvas.toDataURL('image/png');
                    stopCamera();
                    imageQueue = []; currentImageIndex = -1; scrollerContainer.style.display = 'none';
                    initCropper(dataUrl, `capture-${Date.now()}.png`);
                } else {
                    // Clear only visual state
                    stopCamera();
                    placeholder.style.display = 'block';
                    previewCanvas.style.display = 'none';
                    imagePreview.src = '';
                    fileInput.value = ''; currentRotation = 0;
                    isImageLocked = false; lockBtn.textContent = 'Lock'; lockBtn.style.backgroundColor = '';
                    imageQueue = []; currentImageIndex = -1;
                    scroller.innerHTML = ''; scrollerContainer.style.display = 'none';
                    inlineCropperWrapper.style.display = 'none';
                    imageViewArea.style.display = 'flex';
                    selectionCanvas.style.display = 'none';

                    const portraitConstraints = { video: { facingMode: { ideal: "environment" }, width: { ideal: 1080 }, height: { ideal: 1920 }, aspectRatio: { ideal: 3/4 } } };
                    const fallbackConstraints = { video: { facingMode: { ideal: "environment" } } };
                    const finalFallback = { video: true };
                    try {
                        stream = await navigator.mediaDevices.getUserMedia(portraitConstraints);
                    } catch (err) {
                        try { stream = await navigator.mediaDevices.getUserMedia(fallbackConstraints); } catch (err2) {
                            try { stream = await navigator.mediaDevices.getUserMedia(finalFallback); } catch (e) {
                               updateStatus("Could not access camera.", true); return;
                            }
                        }
                    }
                    cameraFeed.style.display = 'block';
                    cameraFeed.srcObject = stream;
                    cameraFeed.play(); 
                    setInterfaceState('streaming');
                    cameraFeed.addEventListener('click', handleVideoStreamClick);
                }
            });
            uploadBtn.addEventListener('click', () => { fileInput.click(); });
            fileInput.addEventListener('change', async (event) => {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;
                updateStatus('Processing uploaded files...');
                let processedFiles = [];
                for (const file of files) {
                    if (file.type === 'application/pdf') {
                        try {
                            const pdfImages = await handlePdfFile(file);
                            processedFiles.push(...pdfImages);
                        } catch (error) { updateStatus(`Failed to process PDF: ${file.name}`, true); }
                    } else if (file.type.startsWith('image/')) {
                        processedFiles.push(file);
                    }
                }
                if (processedFiles.length > MAX_FILES) {
                    updateStatus(`Max ${MAX_FILES} files allowed. Loading first ${MAX_FILES}.`, true);
                    processedFiles = processedFiles.slice(0, MAX_FILES);
                }
                if (processedFiles.length === 0) {
                    updateStatus('No valid images found or processed.', true); return;
                }
                imageQueue = processedFiles;
                scrollerContainer.style.display = imageQueue.length > 1 ? 'block' : 'none';
                if (imageQueue.length > 1) renderScroller();
                displayImage(0);
                updateStatus(`${imageQueue.length} image(s) loaded.`);
            });
            async function handlePdfFile(file) {
                const fileReader = new FileReader();
                return new Promise((resolve, reject) => {
                    fileReader.onload = async (e) => {
                        try {
                            const typedarray = new Uint8Array(e.target.result);
                            const pdf = await pdfjsLib.getDocument(typedarray).promise;
                            const imageFiles = [];
                            const scale = 2.0;
                            for (let i = 1; i <= pdf.numPages; i++) {
                                updateStatus(`Processing PDF page ${i} of ${pdf.numPages}...`);
                                const page = await pdf.getPage(i);
                                const viewport = page.getViewport({ scale });
                                const canvas = document.createElement('canvas');
                                const context = canvas.getContext('2d');
                                canvas.height = viewport.height;
                                canvas.width = viewport.width;
                                const renderContext = { canvasContext: context, viewport: viewport };
                                await page.render(renderContext).promise;
                                const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
                                const pageFile = await dataURLtoFile(dataUrl, `${file.name}-page-${i}.jpg`);
                                imageFiles.push(pageFile);
                            }
                            resolve(imageFiles);
                        } catch (error) { reject(error); }
                    };
                    fileReader.onerror = reject;
                    fileReader.readAsArrayBuffer(file);
                });
            }
            rotateBtn.addEventListener('click', () => {
                if (previewCanvas.style.display === 'block') {
                    currentRotation = (currentRotation + 90) % 360;
                    drawPreview();
                    scanBarcodeFromPreview();
                }
            });
            lockBtn.addEventListener('click', () => {
                isImageLocked = !isImageLocked;
                lockBtn.textContent = isImageLocked ? 'Unlock' : 'Lock';
                lockBtn.style.backgroundColor = isImageLocked ? '#d4edda' : '';
            });
            cancelBtn.addEventListener('click', () => {
                if (stream) {
                    if (cancelBtn.textContent === 'Done') {
                        stopCamera();
                        if (imageQueue.length > 0) displayImage(0);
                        else resetUploader();
                    } else {
                        resetUploader();
                    }
                    return;
                }
                if (isImageLocked) { resetUploader(); return; }
                if (imageQueue.length > 0) {
                     imageQueue.splice(currentImageIndex, 1);
                     renderScroller();
                     displayImage(currentImageIndex < imageQueue.length ? currentImageIndex : 0);
                } else { resetUploader(); }
            });
            cancelAllBtn.addEventListener('click', resetUploader);
            imageViewArea.addEventListener('mousedown', onSelectionStart);
            imageViewArea.addEventListener('touchstart', onSelectionStart, { passive: false });
            
            // --- MODIFIED: pickBtn ---
            pickBtn.addEventListener('click', async () => {
                if (!imagePreview.src) {
                    updateStatus("No image to pick.", true); return;
                }
                const awbValue = awbInput.value.trim();
                if (awbValue === '') {
                    updateStatus("Please enter AWB / Ref / KYC Number.", true); awbInput.focus(); return;
                }
                if (/\s/.test(awbValue)) {
                    updateStatus("AWB / Ref / KYC Number cannot contain spaces.", true); awbInput.focus(); return;
                }
                if (isDuplicateEntry()) return;
                if (tableBody.rows.length >= MAX_ROWS) {
                    updateStatus("Table is full.", true); return;
                }
                const rotatedImageSrc = await getRotatedImage(imagePreview.src, currentRotation);
                const finalImageSrc = await compressImage(rotatedImageSrc, 100, 1024);
                
                let rowData = [];
                const newRow = tableBody.insertRow();
                newRow.dataset.ref = selectedOrderRefInput.value || '';
                newRow.dataset.branch = selectedOrderBranchInput.value || '';
                newRow.dataset.code = selectedOrderCodeInput.value || '';
                
                if (currentUploadType === 'KYC') {
                    const customerName = customerNameInput.value.trim();
                    if (!customerName) {
                        updateStatus("Customer name is required for KYC.", true); customerNameInput.focus(); tableBody.deleteRow(-1); return;
                    }
                    const kycType = kycTypeSelect.value;
                    rowData = [ tableBody.rows.length, awbValue, customerName, kycType, currentUploadType ];
                    newRow.dataset.customerUid = selectedCustomerUidInput.value || '';
                } else if (currentUploadType === 'Product') {
                     const docNumber = docNumberInput.value.trim();
                     if (!docNumber) {
                         updateStatus("Doc Number is required for Product.", true); docNumberInput.focus(); tableBody.deleteRow(-1); return;
                     }
                    rowData = [ tableBody.rows.length, awbValue, docTypeSelect.value, docNumber, currentUploadType ];
                } else {
                     let remarkValue;
                    if (currentUploadType === 'MultiBox') {
                        remarkValue = remarkInput.value.trim() || awbValue;
                    } else {
                        remarkValue = remarkInput.value.trim() || getDefaultRemark(currentUploadType);
                    }
                    rowData = [ tableBody.rows.length, awbValue, remarkValue, currentUploadType ];
                }
                
                rowData.forEach(text => { newRow.insertCell().textContent = text; });
                const imageCell = newRow.insertCell();
                const thumb = document.createElement('img');
                thumb.src = finalImageSrc;
                const cellDiv = document.createElement('div');
                cellDiv.className = 'image-cell-content';
                cellDiv.appendChild(thumb);
                imageCell.appendChild(cellDiv);
                
                if ((currentUploadType === 'Product' || currentUploadType === 'MultiBox') && !isAwbLockedForProduct) {
                    isAwbLockedForProduct = true; awbInput.disabled = true;
                }
                if (currentUploadType === 'KYC' && !isCustomerNameLockedForKyc) {
                    isCustomerNameLockedForKyc = true; customerNameInput.disabled = true;
                }
                awbInput.value = (isAwbLockedForProduct || currentUploadType === 'KYC') ? awbInput.value : '';
                remarkInput.value = '';
                customerNameInput.value = isCustomerNameLockedForKyc ? customerNameInput.value : '';
                docNumberInput.value = '';
                if (!isImageLocked) {
                    if (imageQueue.length > 0) {
                        imageQueue.splice(currentImageIndex, 1);
                        renderScroller();
                        displayImage(currentImageIndex < imageQueue.length ? currentImageIndex : 0);
                    } else {
                        resetUploader();
                    }
                } else {
                    if(currentUploadType === 'Product') docNumberInput.focus();
                    else if(currentUploadType === 'MultiBox') remarkInput.focus();
                    else awbInput.focus();
                }
            });

            deleteLastBtn.addEventListener('click', () => { if (tableBody.rows.length > 0) tableBody.deleteRow(-1); });
            clearAllBtn.addEventListener('click', () => { 
                tableBody.innerHTML = ''; 
                if (currentUploadType === 'Product' || currentUploadType === 'MultiBox') {
                    isAwbLockedForProduct = false; awbInput.disabled = false; awbInput.value = '';
                }
                if (currentUploadType === 'KYC') {
                    isCustomerNameLockedForKyc = false; customerNameInput.disabled = false; customerNameInput.value = ''; awbInput.value = '';
                }
            });
            
            // --- MODIFIED: submitBtn ---
            submitBtn.addEventListener('click', async () => {
                const rows = tableBody.rows;
                const gscriptUrl = gscriptUrlInput.value.trim();
                if (rows.length === 0) {
                    updateStatus("No data in the table to submit.", true); return;
                }
                if (!gscriptUrl || !gscriptUrl.startsWith('https://script.google.com/macros/s/')) {
                    updateStatus("Please provide a valid Google Apps Script Web App URL.", true); gscriptUrlInput.focus(); return;
                }
                submitBtn.disabled = true;
                let successCount = 0;
                
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    updateStatus(`Submitting row ${i + 1} of ${rows.length}...`);
                    const imgElement = row.cells[row.cells.length - 1].querySelector('img');
                    if (!imgElement) continue;
                    
                    const rowUploadType = row.cells[row.cells.length - 2].textContent;
                    const rowData = {};
                    rowData.uploadType = rowUploadType;
                    rowData.refNumber = row.dataset.ref || '';
                    rowData.branch = row.dataset.branch || '';
                    rowData.code = row.dataset.code || '';

                    if (rowUploadType === 'KYC') {
                        rowData.kycNumber = row.cells[1].textContent;
                        rowData.customerName = row.cells[2].textContent;
                        rowData.kycType = row.cells[3].textContent;
                        rowData.customerUid = row.dataset.customerUid || '';
                    } else if (rowUploadType === 'Product') {
                        rowData.awbNumber = row.cells[1].textContent;
                        rowData.docType = row.cells[2].textContent;
                        rowData.docNumber = row.cells[3].textContent;
                    } else if (rowUploadType === 'MultiBox') {
                        rowData.awbNumber = row.cells[1].textContent;
                        rowData.childAwb = row.cells[2].textContent; 
                    } else { // POD, Reciept
                        rowData.awbNumber = row.cells[1].textContent;
                        rowData.statusRemark = row.cells[2].textContent;
                    }

                    const payload = {
                        imageData: imgElement.src,
                        fileName: `${rowData.awbNumber || rowData.kycNumber || rowData.docNumber}-${Date.now()}.jpg`,
                        rowData: rowData,
                    };
                    
                    try {
                        const response = await fetch(gscriptUrl, {
                            method: 'POST',
                            body: JSON.stringify(payload),
                            headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                            mode: 'cors',
                        });
                        const result = await response.json();
                        if (result.status === 'success') {
                            successCount++;
                             row.style.backgroundColor = '#d4edda';
                        } else {
                            throw new Error(result.message);
                        }
                    } catch (error) {
                        console.error('Submission error:', error);
                        row.style.backgroundColor = '#f8d7da';
                        updateStatus(`Error submitting row ${i + 1}: ${error.message}`, true);
                        submitBtn.disabled = false;
                        return;
                    }
                }
                updateStatus(`Successfully submitted ${successCount} of ${rows.length} rows.`, false);
                setTimeout(() => {
                    clearAllBtn.click();
                     updateStatus('All data submitted and table cleared.');
                }, 2000);
                submitBtn.disabled = false;
            });

            // Enhancement Listeners
            enhanceBtn.addEventListener('click', () => { enhancementControls.style.display = enhancementControls.style.display === 'block' ? 'none' : 'block'; });
            resetEnhanceBtn.addEventListener('click', () => {
                if (!cropper) return;
                updateStatus("Resetting enhancements...");
                currentEnhancements = { brightness: 0, contrast: 0, sharpen: false, greyscale: false, bw: false };
                brightnessSlider.value = 0;
                contrastSlider.value = 0;
                sharpenBtn.style.backgroundColor = '';
                greyscaleBtn.style.backgroundColor = '';
                bwBtn.style.backgroundColor = '';
                cropper.replace(originalCropperSrc);
                updateStatus("Enhancements reset.");
            });
            const applyEnhanceDebounce = () => { currentEnhancements.brightness = brightnessSlider.value; currentEnhancements.contrast = contrastSlider.value; applyEnhancements(); };
            brightnessSlider.addEventListener('input', applyEnhanceDebounce);
            contrastSlider.addEventListener('input', applyEnhanceDebounce);
            sharpenBtn.addEventListener('click', () => { currentEnhancements.sharpen = !currentEnhancements.sharpen; sharpenBtn.style.backgroundColor = currentEnhancements.sharpen ? '#d4edda' : ''; applyEnhancements(); });
            greyscaleBtn.addEventListener('click', () => {
                currentEnhancements.greyscale = !currentEnhancements.greyscale;
                if (currentEnhancements.greyscale) { currentEnhancements.bw = false; bwBtn.style.backgroundColor = ''; }
                greyscaleBtn.style.backgroundColor = currentEnhancements.greyscale ? '#d4edda' : ''; applyEnhancements();
            });
            bwBtn.addEventListener('click', () => {
                currentEnhancements.bw = !currentEnhancements.bw;
                if (currentEnhancements.bw) { currentEnhancements.greyscale = false; greyscaleBtn.style.backgroundColor = ''; }
                bwBtn.style.backgroundColor = currentEnhancements.bw ? '#d4edda' : ''; applyEnhancements();
            });
            autoEnhanceBtn.addEventListener('click', () => {
                currentEnhancements.sharpen = true; currentEnhancements.brightness = 10; currentEnhancements.contrast = 10;
                currentEnhancements.greyscale = false; currentEnhancements.bw = false;
                brightnessSlider.value = currentEnhancements.brightness;
                contrastSlider.value = currentEnhancements.contrast;
                sharpenBtn.style.backgroundColor = '#d4edda';
                greyscaleBtn.style.backgroundColor = '';
                bwBtn.style.backgroundColor = '';
                applyEnhancements();
            });
            // This function needs to be defined before it's used by the listeners above
            applyEnhancements = () => {
                if (!cropper || !originalCropperSrc) return;
                updateStatus("Applying enhancements...");
                const tempCanvas = document.createElement('canvas');
                const tempImg = new Image();
                tempImg.crossOrigin = "Anonymous";
                tempImg.onload = () => {
                    tempCanvas.width = tempImg.width;
                    tempCanvas.height = tempImg.height;
                    tempCanvas.getContext('2d').drawImage(tempImg, 0, 0);
                    Caman(tempCanvas, function () {
                        this.revert(false);
                        if (currentEnhancements.bw) { this.greyscale().contrast(70).brightness(5); }
                        else if (currentEnhancements.greyscale) { this.greyscale(); }
                        if (currentEnhancements.sharpen) { this.sharpen(10); }
                        this.brightness(parseInt(currentEnhancements.brightness, 10));
                        this.contrast(parseInt(currentEnhancements.contrast, 10));
                        this.render(() => {
                            const newDataUrl = this.toBase64();
                            cropper.replace(newDataUrl);
                            updateStatus('Enhancements applied.');
                        });
                    });
                };
                tempImg.src = originalCropperSrc;
            }

            // Keyboard navigation
            const inputFields = [ awbInput, customerNameInput, kycTypeSelect, docTypeSelect, docNumberInput, remarkInput ];
            function handleEnterKey(e) {
                if (e.key !== 'Enter') return;
                e.preventDefault();
                const currentField = e.target;
                const isRequiredAndEmpty = (field) => {
                    if (field.style.display === 'none' || field.disabled) return false;
                    const value = field.value.trim();
                    if (value === '') {
                        if (field === awbInput) return true;
                        if (field === customerNameInput && currentUploadType === 'KYC') return true;
                        if (field === docNumberInput && currentUploadType === 'Product') return true;
                    }
                    return false;
                };
                if (isRequiredAndEmpty(currentField)) {
                    let fieldName = "This field";
                    if(currentField.placeholder) fieldName = currentField.placeholder.replace('(Required)','').trim();
                    updateStatus(`${fieldName} is a required field.`, true);
                    return;
                }
                const visibleFields = inputFields.filter(field => field.style.display !== 'none' && !field.disabled);
                const currentIndex = visibleFields.indexOf(e.target);
                if (currentIndex > -1 && currentIndex < visibleFields.length - 1) {
                    visibleFields[currentIndex + 1].focus();
                } else {
                    pickBtn.click();
                }
            }
            inputFields.forEach(field => {
                field.addEventListener('keydown', handleEnterKey);
            });

            // --- Final Initialization ---
            updateUIForUploadType(currentUploadType);
            
            // --- FIX: Check for cached appData ---
            const appDataJSON = localStorage.getItem('appData');
            if (appDataJSON) {
                console.log("DEBUG: Found appData in cache on load.");
                try {
                    const appData = JSON.parse(appDataJSON);
                    if (appData.data) {
                        initializeOrderData({ detail: appData });
                    } else {
                         console.error("DEBUG: Cached appData is invalid.");
                         updateStatus("Cached data is invalid. Waiting for network.", true);
                    }
                } catch (e) {
                     console.error("DEBUG: Failed to parse cached appData.", e);
                     updateStatus("Failed to parse cached data. Waiting for network.", true);
                }
            } else {
                console.log("DEBUG: No appData in cache. Waiting for appDataLoaded event.");
                // The 'appDataLoaded' listener will handle it
            }
        });
    </script>
</body>
</html>

