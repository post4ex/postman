<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uploader - Postman</title>
    <!-- Google Fonts & Tailwind CSS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Site Styles -->
    <link rel="stylesheet" href="style.css">
    <!-- Cropper.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
    <style>
        body { font-family: 'Inter', sans-serif; display: flex; flex-direction: column; min-height: 100vh; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-radius: 50%; border-top: 4px solid #4338ca; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Explicit Button Styling */
        .uploader-container button {
            padding: 8px 16px; border: 1px solid #ccc; background-color: #fff; border-radius: 4px;
            cursor: pointer; font-weight: 500; color: #333; transition: background-color 0.2s, border-color 0.2s;
        }
        .uploader-container button:hover { background-color: #f0f0f0; border-color: #bbb; }
        .uploader-container button:disabled { background-color: #e9ecef; cursor: not-allowed; opacity: 0.7; }
        
        /* General Uploader Styles */
        .uploader-container {
            display: flex; flex-direction: column; align-items: center; gap: 15px;
            width: 100%; box-sizing: border-box;
        }
        #gscript-container {
            width: 100%; padding: 10px; background-color: #fffbe6; border-radius: 8px; border: 1px solid #ffeeba;
        }
        #gscript-container input { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
        
        #main-controls-strip {
            width: 100%; display: flex; justify-content: center; align-items: center;
            gap: 10px; flex-wrap: wrap; padding: 8px; background-color: #e9ecef;
            border-radius: 8px; box-sizing: border-box;
        }
        .upload-type-strip, .button-group {
            display: flex; flex-wrap: wrap; gap: 8px;
            align-items: center; justify-content: center;
        }
        .separator {
            width: 1px; height: 28px; background-color: #ced4da;
        }
        @media (max-width: 680px) { .separator { display: none; } }

        .type-btn { padding: 6px 12px; }
        .type-btn.active {
            background-color: #1E3A8A; color: #fff; border-color: #1E3A8A; font-weight: bold;
        }
        .type-btn.active:hover { background-color: #1c347a; }
        
        #image-scroller-container {
            width: 100%; height: 80px; background-color: #eee; border: 1px solid #ddd;
            border-radius: 4px; padding: 5px; box-sizing: border-box; display: none;
        }
        #image-scroller {
            height: 100%; display: flex; gap: 5px; overflow-x: auto; white-space: nowrap;
        }
        .scroller-img {
            height: 100%; width: 70px; object-fit: cover; cursor: pointer;
            border: 2px solid transparent; border-radius: 2px; transition: border-color 0.2s;
        }
        .scroller-img.active { border-color: #1E3A8A; }
        
        #image-view-area {
            border: 2px dashed #ccc; width: 100%; aspect-ratio: 4 / 3; display: flex;
            justify-content: center; align-items: center; text-align: center; color: #888;
            position: relative; overflow: hidden; background-color: #f0f0f0;
            cursor: default;
        }
        #image-view-area.selectable { cursor: crosshair; }
        #image-preview { display: none; }
        #camera-feed, #preview-canvas {
            width: 100%; height: 100%; object-fit: contain;
        }
        #camera-feed.active-capture { cursor: pointer; }
        #preview-canvas { display: none; }

        #rotate-btn, #lock-btn, #cancel-btn, #cancel-all-btn, #file-input { display: none; }
        .entry-input-group { display: flex; flex-wrap: wrap; gap: 8px; width: 100%; align-items: center; }
        .entry-input-group input, .entry-input-group select { padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; }
        
        .data-table-container { width: 100%; margin-top: 5px; overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; font-size: 14px; }
        th { background-color: #f0f0f0; }
        td .image-cell-content { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; }
        td .image-cell-content img { max-width: 100%; max-height: 100%; object-fit: contain; }
        #table-actions { width: 100%; margin-top: 15px; }

        #inline-cropper-wrapper {
            display: none; width: 100%; padding: 10px; box-sizing: border-box;
            background-color: #f0f0f0; border: 2px dashed #1E3A8A; 
        }
        #cropper-container { width: 100%; height: 60vh; }
        #cropper-image { display: block; max-width: 100%; }
        
        #selection-canvas {
            position: absolute; top: 0; left: 0; display: none; z-index: 10;
        }
        
        #status-bar {
            width: 100%; padding: 8px; box-sizing: border-box; min-height: 2.5em;
            text-align: center; background-color: #e9ecef; border-radius: 4px; color: #495057;
        }
        #status-bar.error { color: #dc3545; font-weight: bold; }

        .slider-control { display: flex; align-items: center; gap: 10px; width: 100%; max-width: 280px; justify-content: center; }
        .enhancement-sliders { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 15px; }
        input[type="range"] { flex-grow: 1; }

        .main-content-wrapper { display: flex; flex-direction: column; width: 100%; gap: 15px; }
        .preview-column, .controls-column { width: 100%; }
        .controls-column { display: flex; flex-direction: column; gap: 15px; }

        @media (min-width: 1024px) {
            .main-content-wrapper { flex-direction: row; align-items: flex-start; }
            .preview-column { flex: 1.5; min-width: 0; }
            .controls-column { flex: 1; min-width: 0; }
            .data-table-container, #table-actions { margin-top: 0; }
        }
        
        /* Sidebar styles */
        #orderListContainer {
            transition: width 0.3s ease-in-out, padding 0.3s ease-in-out;
            overflow: hidden; /* Hide content when collapsed */
        }

        #orderListContainer.collapsed {
            width: 0 !important; /* Force width to 0 */
            padding-left: 0 !important;
            padding-right: 0 !important;
            border-right-width: 0 !important; /* Hide border */
        }
        
        #uploaderFormContainer.expanded {
            width: 100% !important; /* On mobile/desktop when sidebar collapsed */
        }

        /* Adjust main content layout */
        main.w-full { /* Ensure main tag takes full width */
          display: flex; /* Make main a flex container */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">

    <div id="header-placeholder"></div>

    <main class="w-full flex-grow flex flex-col md:flex-row md:h-[calc(100vh-88px)]">
        
        <!-- === Order List Sidebar === -->
        <aside id="orderListContainer" class="w-full md:w-1/3 lg:w-1/4 bg-white border-r flex flex-col relative md:relative transition-all duration-300 ease-in-out">
            <button id="toggleOrderListBtn" class="absolute top-3 right-3 z-20 p-1 rounded-md bg-gray-200 hover:bg-gray-300 text-gray-600">
                 <svg id="collapseIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                 <svg id="expandIcon" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
            </button>
            <div class="p-4 border-b sticky top-0 bg-white z-10">
                <div class="flex justify-between items-center">
                    <h2 class="text-xl font-bold text-gray-800">Orders</h2>
                    <button id="newOrderBtn" class="text-sm bg-indigo-100 text-indigo-700 font-semibold py-1 px-3 rounded-lg hover:bg-indigo-200 transition-colors">New</button>
                </div>
                <input type="text" id="searchOrder" placeholder="Search AWB, Ref, Client..." class="mt-2 w-full p-2 border border-gray-300 rounded-lg text-sm focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div class="overflow-y-auto flex-grow">
                <ul id="orderList" class="p-4 space-y-2">
                    <li id="orderLoader" class="text-center text-gray-500">Loading orders...</li>
                </ul>
            </div>
        </aside>

        <!-- === Uploader Form (Main Content) === -->
        <div id="uploaderFormContainer" class="w-full md:w-2/3 lg:w-3/4 p-4 sm:p-8 overflow-y-auto hidden md:block transition-all duration-300 ease-in-out">
            <!-- Mobile: Back to List Button -->
             <div class="p-4 border-b md:hidden bg-white -mt-4 -mx-4 sm:-mt-8 sm:-mx-8 mb-8">
                 <button type="button" id="backToListBtn" class="text-sm bg-gray-200 text-gray-800 font-semibold py-1 px-3 rounded-lg hover:bg-gray-300 flex items-center">
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                    Back to List
                </button>
            </div>

            <!-- Existing Card Wrapper -->
            <div class="card">
                <div class="uploader-container">
                    <!-- Google Apps Script URL Input -->
                    <div id="gscript-container" style="display: none;">
                        <label for="gscript-url"><b>Paste your Google Apps Script Web App URL here:</b></label>
                        <input type="text" id="gscript-url" placeholder="https://script.google.com/macros/s/.../exec" value="https://script.google.com/macros/s/AKfycbwkC3OXNACPPH-LLPJyhkZKaDh6VtNgGbp8lMQbzz1XF327IN_OhFEEapOzNm3REbn5/exec">
                    </div>

                    <!-- Main Controls -->
                    <div id="main-controls-strip">
                        <div class="upload-type-strip">
                            <button class="type-btn active" data-type="POD">POD</button>
                            <button class="type-btn" data-type="Reciept">Reciept</button>
                            <button class="type-btn" data-type="KYC">KYC</button>
                            <button class="type-btn" data-type="Product">Product</button>
                            <button class="type-btn" data-type="MultiBox">MultiBox</button>
                        </div>
                        <div class="separator"></div>
                        <div class="button-group">
                            <button id="camera-btn">Camera</button>
                            <button id="upload-btn">Upload</button>
                            <button id="rotate-btn">Rotate</button>
                            <button id="lock-btn">Lock</button>
                            <button id="cancel-btn">Cancel</button>
                            <button id="cancel-all-btn">Cancel All</button>
                            <input type="file" id="file-input" accept="image/*,application/pdf" multiple>
                        </div>
                    </div>

                    <!-- Scroller -->
                    <div id="image-scroller-container"><div id="image-scroller"></div></div>
                    
                    <div class="main-content-wrapper">
                        <div class="preview-column">
                            <!-- Inline Cropper -->
                            <div id="inline-cropper-wrapper">
                                <div id="cropper-container">
                                    <img id="cropper-image" src="">
                                </div>
                                <div class="button-group" style="margin-top: 10px;">
                                    <button id="crop-rotate-btn">Rotate</button>
                                    <button id="enhance-btn">Enhance</button>
                                    <button id="crop-confirm-btn">Crop</button>
                                    <button id="crop-cancel-btn">Cancel</button>
                                </div>
                                <div id="enhancement-controls" style="display:none; margin-top:10px; padding-top:10px; border-top: 1px solid #ccc;">
                                    <div class="button-group">
                                         <button id="auto-enhance-btn">Auto</button>
                                        <button id="greyscale-btn">Greyscale</button>
                                        <button id="bw-btn">B&W Doc</button>
                                        <button id="sharpen-btn">Sharpen</button>
                                        <button id="reset-enhance-btn" style="background-color: #f8d7da;">Reset</button>
                                    </div>
                                    <div class="enhancement-sliders">
                                        <div class="slider-control">
                                            <label for="brightness-slider">Brightness</label>
                                            <input type="range" id="brightness-slider" min="-50" max="50" value="0">
                                        </div>
                                        <div class="slider-control">
                                            <label for="contrast-slider">Contrast</label>
                                            <input type="range" id="contrast-slider" min="-50" max="50" value="0">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Preview Area -->
                            <div id="image-view-area" class="flex items-center justify-center"> {/* MODIFIED: Centering classes */}
                                <span id="placeholder">Image preview area</span>
                                <img id="image-preview" src="" alt="Image preview"/>
                                <canvas id="preview-canvas"></canvas>
                                <canvas id="selection-canvas"></canvas>
                                <video id="camera-feed" autoplay playsinline></video>
                            </div>
                        </div>
                        <div class="controls-column">
                            <!-- Status Bar -->
                            <div id="status-bar"></div>

                            <!-- Inputs -->
                            <div class="entry-input-group">
                                <input type="text" id="awb-input" placeholder="Enter AWB / Ref (Required)">
                                
                                <input type="text" id="customer-name-input" placeholder="Enter Customer Name" style="display: none;" list="customer-list">
                                <datalist id="customer-list"></datalist>
                                
                                <select id="kyc-type-select" style="display: none;">
                                    <optgroup label="Individual">
                                        <option value="Aadhaar Card">Aadhaar Card</option>
                                        <option value="PAN Card">PAN Card</option>
                                        <option value="Indian Passport">Indian Passport</option>
                                        <option value="Voter ID Card">Voter ID Card</option>
                                        <option value="Driving License">Driving License</option>
                                        <option value="NREGA Job Card">NREGA Job Card</option>
                                    </optgroup>
                                    <optgroup label="Business">
                                        <option value="Partnership Deed">Partnership Deed</option>
                                        <option value="Certificate of Incorporation">Certificate of Incorporation</option>
                                        <option value="GST Registration">GST Registration</option>
                                        <option value="MoA & AoA">MoA & AoA</option>
                                        <option value="Board Resolution">Board Resolution</option>
                                    </optgroup>
                                </select>
                                <select id="doc-type-select" style="display: none;">
                                    <option value="INV">INV</option>
                                    <option value="EWB">EWB</option>
                                    <option value="CLN">CLN</option>
                                    <option value="ADH">ADH</option>
                                    <option value="DBT">DBT</option>
                                    <option value="CDT">CDT</option>
                                    <option value="HRD">HRD</option>
                                    <option value="AGT">AGT</option>
                                    <option value="INT">INT</option>
                                </select>

                                <input type="text" id="doc-number-input" placeholder="Enter Doc Number" style="display: none;" list="doc-number-list">
                                <datalist id="doc-number-list"></datalist>

                                <input type="text" id="remark-input" placeholder="Status Remark (Default: Delivered)">
                                <button id="pick-btn">Pick</button>
                            </div>
                            <!-- Table -->
                            <div class="data-table-container">
                                <table>
                                    <thead>
                                        <tr id="table-header-row"></tr>
                                    </thead>
                                    <tbody id="data-table-body"></tbody>
                                </table>
                            </div>
                            <!-- Table Actions -->
                            <div class="button-group" id="table-actions">
                                <button id="delete-last-btn">Delete Last</button>
                                <button id="clear-all-btn">Clear All</button>
                                <button id="submit-btn">Submit</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <div id="footer-placeholder"></div>

    <script src="layout.js"></script>

    <!-- *** MOVED Third-party libraries HERE *** -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/camanjs/4.1.2/caman.full.min.js"></script>

    <script>
        // Set up PDF.js worker - NOW this will run AFTER pdf.min.js is loaded
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;

        // === ALL ORIGINAL SCRIPT LOGIC IS HERE (UNCHANGED from previous version) ===
        const gscriptUrlInput = document.getElementById('gscript-url');
        const cameraBtn = document.getElementById('camera-btn'), uploadBtn = document.getElementById('upload-btn'),
              fileInput = document.getElementById('file-input'), placeholder = document.getElementById('placeholder'),
              imagePreview = document.getElementById('image-preview'), cameraFeed = document.getElementById('camera-feed'),
              previewCanvas = document.getElementById('preview-canvas'),
              rotateBtn = document.getElementById('rotate-btn'), lockBtn = document.getElementById('lock-btn'),
              cancelBtn = document.getElementById('cancel-btn'), cancelAllBtn = document.getElementById('cancel-all-btn'),
              pickBtn = document.getElementById('pick-btn'), tableBody = document.getElementById('data-table-body'),
              awbInput = document.getElementById('awb-input'), remarkInput = document.getElementById('remark-input'),
              customerNameInput = document.getElementById('customer-name-input'),
              kycTypeSelect = document.getElementById('kyc-type-select'),
              docTypeSelect = document.getElementById('doc-type-select'),
              docNumberInput = document.getElementById('doc-number-input'),
              deleteLastBtn = document.getElementById('delete-last-btn'), clearAllBtn = document.getElementById('clear-all-btn'),
              submitBtn = document.getElementById('submit-btn'), scrollerContainer = document.getElementById('image-scroller-container'),
              scroller = document.getElementById('image-scroller'), 
              inlineCropperWrapper = document.getElementById('inline-cropper-wrapper'),
              imageViewArea = document.getElementById('image-view-area'),
              cropperImage = document.getElementById('cropper-image'), cropConfirmBtn = document.getElementById('crop-confirm-btn'),
              cropCancelBtn = document.getElementById('crop-cancel-btn'),
              cropRotateBtn = document.getElementById('crop-rotate-btn'),
              selectionCanvas = document.getElementById('selection-canvas'),
              statusBar = document.getElementById('status-bar'),
              uploadTypeStrip = document.querySelector('.upload-type-strip'),
              tableHeaderRow = document.getElementById('table-header-row'),
              // Enhancement DOM Elements
              enhanceBtn = document.getElementById('enhance-btn'),
              enhancementControls = document.getElementById('enhancement-controls'),
              autoEnhanceBtn = document.getElementById('auto-enhance-btn'),
              greyscaleBtn = document.getElementById('greyscale-btn'),
              bwBtn = document.getElementById('bw-btn'),
              sharpenBtn = document.getElementById('sharpen-btn'),
              resetEnhanceBtn = document.getElementById('reset-enhance-btn'),
              brightnessSlider = document.getElementById('brightness-slider'),
              contrastSlider = document.getElementById('contrast-slider');


        // State Variables
        let stream = null, currentRotation = 0, isImageLocked = false, cropper = null;
        let imageQueue = [], currentImageIndex = -1;
        let barcodeDetector;
        let originalCropperSrc = null; // For image enhancement reset
        let currentUploadType = 'POD'; // Default upload type
        let isAwbLockedForProduct = false;
        let isCustomerNameLockedForKyc = false;
        const MAX_FILES = 50, MAX_ROWS = 20;

        // OCR Selection State
        let isSelecting = false, selectionRect = {};
        let isProcessingOCR = false;
        const selectionCtx = selectionCanvas.getContext('2d');
        const previewCtx = previewCanvas.getContext('2d');


        // --- Barcode Detector Initialization ---
        if (!('BarcodeDetector' in window)) {
            console.log('Barcode Detector is not supported by this browser.');
        } else {
            console.log('Barcode Detector supported!');
            try {
                barcodeDetector = new BarcodeDetector({
                    formats: ['code_128', 'code_39', 'ean_13', 'qr_code', 'upc_a', 'itf']
                });
            } catch (e) {
                console.error('Barcode Detector could not be instantiated.', e);
            }
        }
        
        // --- Status Update Logic ---
        function updateStatus(message, isError = false) {
            statusBar.textContent = message;
            statusBar.classList.toggle('error', isError);
        }

        // --- Scanning Logic ---
        async function scanBarcodeFromPreview() {
            if (!barcodeDetector) {
                updateStatus("Barcode detection not supported. Select area for OCR.", true);
                return;
            }
            if (!imagePreview.src || !imagePreview.src.startsWith('data:')) return;

            try {
                updateStatus("Attempting barcode scan...");
                const barcodes = await barcodeDetector.detect(imagePreview);
                if (barcodes.length > 0) {
                    const barcodeValue = barcodes[0].rawValue;
                    if (currentUploadType === 'MultiBox' && awbInput.disabled) {
                        remarkInput.value = barcodeValue;
                    } else if (currentUploadType === 'Product') {
                        docNumberInput.value = barcodeValue;
                    } else {
                        awbInput.value = barcodeValue;
                    }
                    updateStatus(`Barcode detected: ${barcodeValue}`);
                } else {
                    updateStatus("No barcode found. Please select an area for OCR.");
                }
            } catch (err) {
                console.error("Barcode scan failed:", err);
                updateStatus("Barcode scan failed. Select area for OCR.", true);
            }
        }

        // --- Image Compression Logic ---
        async function compressImage(dataUrl, targetSizeKB, maxDimension) {
            const targetSizeBytes = targetSizeKB * 1024;

            const img = await new Promise(resolve => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.src = dataUrl;
            });

            let { width, height } = img;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            if (width > maxDimension || height > maxDimension) {
                if (width > height) {
                    height = Math.round(height * (maxDimension / width));
                    width = maxDimension;
                } else {
                    width = Math.round(width * (maxDimension / height));
                    height = maxDimension;
                }
            }
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);

            let quality = 0.95;
            let compressedDataUrl;
            let sizeInBytes;

            do {
                compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                sizeInBytes = atob(compressedDataUrl.split(',')[1]).length;
                if (sizeInBytes > targetSizeBytes && quality > 0.1) {
                    quality -= 0.05; // Decrease quality for the next iteration
                }
            } while (sizeInBytes > targetSizeBytes && quality > 0.1);
            
            const finalSize = (sizeInBytes / 1024).toFixed(2);
            console.log(`Image compressed to ${finalSize} KB for target of ${targetSizeKB} KB.`);
            return compressedDataUrl;
        }


        // --- Main App Logic ---
        function setInterfaceState(state) {
            // Default visibility for idle state
            cameraBtn.style.display = 'inline-block';
            uploadBtn.style.display = 'inline-block';
            uploadTypeStrip.style.display = 'flex'; // Show by default
            rotateBtn.style.display = 'none';
            lockBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
            cancelAllBtn.style.display = 'none';
            imageViewArea.classList.remove('selectable');
            cameraFeed.classList.remove('active-capture');

            if (state === 'streaming') {
                cameraBtn.textContent = 'Capture';
                uploadBtn.style.display = 'none';
                cancelBtn.style.display = 'inline-block';
                previewCanvas.style.display = 'none';
                cameraFeed.style.display = 'block';
                cameraFeed.classList.add('active-capture');
                uploadTypeStrip.style.display = 'none'; // Hide type strip
            } else if (state === 'preview') {
                cameraBtn.style.display = 'none';
                uploadBtn.style.display = 'none';
                rotateBtn.style.display = 'inline-block';
                lockBtn.style.display = 'inline-block';
                imageViewArea.classList.add('selectable');
                uploadTypeStrip.style.display = 'none'; // Hide type strip

                if (imageQueue.length > 0) {
                    cancelBtn.style.display = 'inline-block';
                    cancelAllBtn.style.display = 'inline-block';
                } else {
                    cancelBtn.style.display = 'inline-block';
                }
            }
        }


        function resetUploader() {
            stopCamera();
            placeholder.style.display = 'block';
            previewCanvas.style.display = 'none';
            cameraFeed.style.display = 'none'; 
            imagePreview.src = ''; // Clear image source
            fileInput.value = ''; currentRotation = 0;
            isImageLocked = false; lockBtn.textContent = 'Lock'; lockBtn.style.backgroundColor = '';
            imageQueue = []; currentImageIndex = -1;
            scroller.innerHTML = ''; scrollerContainer.style.display = 'none';
            
            inlineCropperWrapper.style.display = 'none';
            imageViewArea.style.display = 'flex';
            selectionCanvas.style.display = 'none';
            updateStatus('');

            isAwbLockedForProduct = false;
            awbInput.disabled = false;
            isCustomerNameLockedForKyc = false;
            customerNameInput.disabled = false;

            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.backgroundColor = '';
            cancelBtn.style.borderColor = '';
            cancelBtn.style.color = '';

            setInterfaceState('idle');
        }

        function stopCamera() { 
            if (stream) { 
                stream.getTracks().forEach(track => track.stop()); 
                stream = null; 
            }
            cameraFeed.removeEventListener('click', handleVideoStreamClick);
        }

        function displayImage(index) {
            if (index < 0 || index >= imageQueue.length) { resetUploader(); return; }
            currentImageIndex = index;
            const file = imageQueue[index];
            const reader = new FileReader();
            reader.onload = (e) => initCropper(e.target.result, file.name);
            reader.readAsDataURL(file);
        }

        function renderScroller() {
            scroller.innerHTML = '';
            imageQueue.forEach((file, index) => {
                const thumb = document.createElement('img');
                try { thumb.src = URL.createObjectURL(file); } catch(e) { console.error("Could not create object URL for", file); }
                thumb.className = 'scroller-img'; thumb.dataset.index = index;
                thumb.onclick = () => displayImage(index);
                scroller.appendChild(thumb);
            });
            updateActiveThumbnail();
        }

        function updateActiveThumbnail() {
            document.querySelectorAll('.scroller-img').forEach((img, index) => {
                img.classList.toggle('active', index === currentImageIndex);
            });
        }
        
        // --- Cropper Logic ---
        function initCropper(imageSrc, originalFileName) {
            originalCropperSrc = imageSrc; // Save the original source for resetting enhancements
            
            // Manually reset state and UI for the new image
            currentEnhancements = { brightness: 0, contrast: 0, sharpen: false, greyscale: false, bw: false };
            if (brightnessSlider) brightnessSlider.value = 0;
            if (contrastSlider) contrastSlider.value = 0;
            if (sharpenBtn) sharpenBtn.style.backgroundColor = '';
            if (greyscaleBtn) greyscaleBtn.style.backgroundColor = '';
            if (bwBtn) bwBtn.style.backgroundColor = '';
            if (enhancementControls) enhancementControls.style.display = 'none';

            inlineCropperWrapper.style.display = 'block';
            imageViewArea.style.display = 'none';
            scrollerContainer.style.display = 'none'; 

            cropperImage.src = imageSrc;
            if (cropper) cropper.destroy();
            cropper = new Cropper(cropperImage, {
                viewMode: 1, // Allow freeform cropping
                background: false,
            });
            
            const confirmCropHandler = async () => {
                const croppedCanvas = cropper.getCroppedCanvas({
                    minWidth: 256,
                    minHeight: 256,
                    maxWidth: 4096,
                    maxHeight: 4096,
                    fillColor: '#fff',
                    imageSmoothingEnabled: true,
                    imageSmoothingQuality: 'high',
                });
                if (!croppedCanvas) { return; }
                let croppedDataUrl = croppedCanvas.toDataURL('image/png');
                
                inlineCropperWrapper.style.display = 'none';
                imageViewArea.style.display = 'flex';
                if (imageQueue.length > 1) scrollerContainer.style.display = 'block';

                imagePreview.onload = () => {
                    drawPreview();
                    scanBarcodeFromPreview();
                    imagePreview.onload = null;
                };
                imagePreview.src = croppedDataUrl; 

                placeholder.style.display = 'none';
                cameraFeed.style.display = 'none';
                previewCanvas.style.display = 'block';
                currentRotation = 0;

                if (currentImageIndex !== -1) {
                    const newFile = await dataURLtoFile(croppedDataUrl, originalFileName.replace(/\.\w+$/, '.png'));
                    imageQueue[currentImageIndex] = newFile;
                    renderScroller();
                }

                setInterfaceState('preview');
                cropConfirmBtn.removeEventListener('click', confirmCropHandler);
            };
            cropConfirmBtn.addEventListener('click', confirmCropHandler, { once: true });
        }
        
        cropCancelBtn.addEventListener('click', () => {
            inlineCropperWrapper.style.display = 'none';
            imageViewArea.style.display = 'flex';
            if (imageQueue.length > 1) scrollerContainer.style.display = 'block';
            if (cropper) cropper.destroy();
            if (!imagePreview.src) {
                resetUploader();
            }
        });
        
        cropRotateBtn.addEventListener('click', () => {
            if (cropper) {
                cropper.rotate(90);
            }
        });

        function drawPreview() {
             if (!imagePreview.src || !imageViewArea || !previewCanvas) return; // Added checks
            const dpr = window.devicePixelRatio || 1;
            const containerW = imageViewArea.clientWidth;
            const containerH = imageViewArea.clientHeight;

            // Check if container has valid dimensions
            if (containerW <= 0 || containerH <= 0) return; 
            
            previewCanvas.width = containerW * dpr;
            previewCanvas.height = containerH * dpr;
            previewCanvas.style.width = `${containerW}px`;
            previewCanvas.style.height = `${containerH}px`;
            
            previewCtx.scale(dpr, dpr);
            
            const naturalW = imagePreview.naturalWidth;
            const naturalH = imagePreview.naturalHeight;

            // Check if image has valid dimensions
            if (naturalW <= 0 || naturalH <= 0) return; 

            const imgAspect = naturalW / naturalH;
            const contAspect = containerW / containerH;
            let renderedW, renderedH;

            if (imgAspect > contAspect) {
                renderedW = containerW; renderedH = containerW / imgAspect;
            } else {
                renderedH = containerH; renderedW = containerH * imgAspect;
            }
            
            previewCtx.clearRect(0, 0, containerW, containerH);
            previewCtx.save();
            previewCtx.translate(containerW / 2, containerH / 2);
            previewCtx.rotate(currentRotation * Math.PI / 180);
            try { // Add try-catch for drawImage
                previewCtx.drawImage(imagePreview, -renderedW / 2, -renderedH / 2, renderedW, renderedH);
            } catch (e) {
                console.error("Error drawing image onto canvas:", e);
                updateStatus("Error displaying preview.", true);
            }
            previewCtx.restore();
        }

        // --- Event Listeners ---
        function updateTableHeader(uploadType) {
            tableHeaderRow.innerHTML = ''; // Clear existing header
            let headers = [];
            if (uploadType === 'KYC') {
                headers = ['Sl No', 'KYC Number', 'Customer Name', 'KYC Type', 'Type', 'Image'];
            } else if (uploadType === 'Product') {
                headers = ['Sl No', 'AWB / Ref', 'Doc Type', 'Doc Number', 'Type', 'Image'];
            } else if (uploadType === 'MultiBox') {
                headers = ['Sl No', 'AWB / Ref', 'Child Awb', 'Type', 'Image'];
            } else {
                headers = ['Sl No', 'AWB / Ref', 'Status Remark', 'Type', 'Image'];
            }
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                tableHeaderRow.appendChild(th);
            });
        }

        function updateUIForUploadType(uploadType) {
            // Reset common fields
            customerNameInput.style.display = 'none';
            kycTypeSelect.style.display = 'none';
            docTypeSelect.style.display = 'none';
            docNumberInput.style.display = 'none';
            remarkInput.style.display = 'inline-block';
            isAwbLockedForProduct = false;
            awbInput.disabled = false;
            isCustomerNameLockedForKyc = false;
            customerNameInput.disabled = false;

            if (uploadType === 'KYC') {
                awbInput.placeholder = "Enter KYC Number";
                remarkInput.style.display = 'none';
                kycTypeSelect.style.display = 'inline-block';
                customerNameInput.style.display = 'inline-block';
            } else if (uploadType === 'Reciept') {
                awbInput.placeholder = "Enter AWB / Ref (Required)";
                remarkInput.placeholder = "Status Remark (Default: Booked)";
            } else if (uploadType === 'MultiBox') {
                awbInput.placeholder = "Enter AWB / Ref (Required)";
                remarkInput.placeholder = "Child Awb";
            } else if (uploadType === 'Product') {
                awbInput.placeholder = "Enter AWB / Ref (Required)";
                docNumberInput.placeholder = "Scan/Enter Doc Number";
                docTypeSelect.style.display = 'inline-block';
                docNumberInput.style.display = 'inline-block';
                remarkInput.style.display = 'none';
            } else { // POD
                awbInput.placeholder = "Enter AWB / Ref (Required)";
                remarkInput.placeholder = "Status Remark (Default: Delivered)";
            }
            
            updateTableHeader(uploadType);
            if (tableBody.rows.length > 0) {
                clearAllBtn.click();
                updateStatus("Table cleared due to type change.", false);
            }
        }


        uploadTypeStrip.addEventListener('click', (e) => {
            if (e.target.classList.contains('type-btn')) {
                const selectedType = e.target.dataset.type;
                if (selectedType === currentUploadType) return;

                const currentActive = uploadTypeStrip.querySelector('.active');
                if (currentActive) currentActive.classList.remove('active');
                e.target.classList.add('active');
                
                currentUploadType = selectedType;
                updateUIForUploadType(currentUploadType);
            }
        });

        cameraBtn.addEventListener('click', async () => {
            if (stream) {
                const canvas = document.createElement('canvas');
                canvas.width = cameraFeed.videoWidth;
                canvas.height = cameraFeed.videoHeight;
                canvas.getContext('2d').drawImage(cameraFeed, 0, 0);
                const dataUrl = canvas.toDataURL('image/png');
                stopCamera();
                imageQueue = []; currentImageIndex = -1; scrollerContainer.style.display = 'none';
                initCropper(dataUrl, `capture-${Date.now()}.png`);
            } else {
                resetUploader();
                const portraitConstraints = { 
                    video: { 
                        facingMode: { ideal: "environment" },
                        width: { ideal: 1080 },
                        height: { ideal: 1920 },
                        aspectRatio: { ideal: 3/4 }
                    } 
                };
                const fallbackConstraints = { video: { facingMode: { ideal: "environment" } } };
                const finalFallback = { video: true };

                try {
                    stream = await navigator.mediaDevices.getUserMedia(portraitConstraints);
                    console.log("Using portrait 3:4 camera stream.");
                } catch (err) {
                    console.warn("Portrait 3:4 failed, trying default environment camera.", err);
                    try {
                        stream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
                    } catch (err2) {
                        console.warn("Environment camera failed, trying any camera.", err2);
                        try {
                           stream = await navigator.mediaDevices.getUserMedia(finalFallback);
                        } catch (e) {
                           updateStatus("Could not access camera.", true);
                           return;
                        }
                    }
                }
                
                placeholder.style.display = 'none';
                cameraFeed.style.display = 'block';
                cameraFeed.srcObject = stream;
                cameraFeed.play(); 
                setInterfaceState('streaming');
                cameraFeed.addEventListener('click', handleVideoStreamClick);
            }
        });

        uploadBtn.addEventListener('click', () => { resetUploader(); fileInput.click(); });
        
        fileInput.addEventListener('change', async (event) => {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            updateStatus('Processing uploaded files...');
            let processedFiles = [];

            for (const file of files) {
                if (file.type === 'application/pdf') {
                    try {
                        const pdfImages = await handlePdfFile(file);
                        processedFiles.push(...pdfImages);
                    } catch (error) {
                        console.error("Error processing PDF:", error);
                        updateStatus(`Failed to process PDF: ${file.name}`, true);
                    }
                } else if (file.type.startsWith('image/')) {
                    processedFiles.push(file);
                }
            }

            if (processedFiles.length > MAX_FILES) {
                updateStatus(`Too many pages/images. Max is ${MAX_FILES}. Only the first ${MAX_FILES} will be loaded.`, true);
                processedFiles = processedFiles.slice(0, MAX_FILES);
            }
            
            if (processedFiles.length === 0) {
                updateStatus('No valid images found or processed.', true);
                return;
            }

            imageQueue = processedFiles;
            scrollerContainer.style.display = imageQueue.length > 1 ? 'block' : 'none';
            if (imageQueue.length > 1) renderScroller();
            displayImage(0);
            updateStatus(`${imageQueue.length} image(s) loaded.`);
        });

        async function handlePdfFile(file) {
            const fileReader = new FileReader();
            
            return new Promise((resolve, reject) => {
                fileReader.onload = async (e) => {
                    try {
                        const typedarray = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;
                        const imageFiles = [];
                        const scale = 2.0; // Render at a higher resolution

                        for (let i = 1; i <= pdf.numPages; i++) {
                            updateStatus(`Processing PDF page ${i} of ${pdf.numPages}...`);
                            const page = await pdf.getPage(i);
                            const viewport = page.getViewport({ scale });

                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;

                            const renderContext = {
                                canvasContext: context,
                                viewport: viewport
                            };
                            await page.render(renderContext).promise;
                            
                            const dataUrl = canvas.toDataURL('image/jpeg', 0.9); // Use jpeg for smaller size
                            const pageFile = await dataURLtoFile(dataUrl, `${file.name}-page-${i}.jpg`);
                            imageFiles.push(pageFile);
                        }
                        resolve(imageFiles);
                    } catch (error) {
                        reject(error);
                    }
                };
                fileReader.onerror = reject;
                fileReader.readAsArrayBuffer(file);
            });
        }

        rotateBtn.addEventListener('click', () => {
            if (previewCanvas.style.display === 'block') {
                currentRotation = (currentRotation + 90) % 360;
                drawPreview();
                scanBarcodeFromPreview(); // Re-scan after rotation
            }
        });
        
        lockBtn.addEventListener('click', () => {
            isImageLocked = !isImageLocked;
            lockBtn.textContent = isImageLocked ? 'Unlock' : 'Lock';
            lockBtn.style.backgroundColor = isImageLocked ? '#d4edda' : '';
        });

        cancelBtn.addEventListener('click', () => {
            // Case 1: In streaming mode (camera is on)
            if (stream) {
                if (cancelBtn.textContent === 'Done') {
                    // This is the "Done" button for multi-capture
                    stopCamera();
                    if (imageQueue.length > 0) {
                        displayImage(0);
                    } else {
                        resetUploader();
                    }
                } else {
                    // This is the "Cancel" button for starting the camera
                    resetUploader();
                }
                return; // Exit after handling streaming case
            }
            
            // Case 2: In preview mode (original logic for deleting one image)
            if (isImageLocked) { resetUploader(); return; }
            if (imageQueue.length > 0) {
                 imageQueue.splice(currentImageIndex, 1);
                 renderScroller();
                 displayImage(currentImageIndex < imageQueue.length ? currentImageIndex : 0);
            } else { resetUploader(); }
        });
        
        cancelAllBtn.addEventListener('click', resetUploader);
        
        // --- OCR Area Selection Listeners ---
        function onSelectionStart(e) {
            if (previewCanvas.style.display !== 'block' || isSelecting || isProcessingOCR) return;
            e.preventDefault();
            
            const rect = imageViewArea.getBoundingClientRect();
            selectionCanvas.width = rect.width;
            selectionCanvas.height = rect.height;
            selectionCanvas.style.display = 'block';

            isSelecting = true;
            const point = e.touches ? e.touches[0] : e;
            selectionRect.startX = point.clientX - rect.left;
            selectionRect.startY = point.clientY - rect.top;

            window.addEventListener('mousemove', onSelectionMove);
            window.addEventListener('touchmove', onSelectionMove, { passive: false });
            window.addEventListener('mouseup', onSelectionUp, { once: true });
            window.addEventListener('touchend', onSelectionUp, { once: true });
        }

        function onSelectionMove(e) {
            if (!isSelecting) return;
            e.preventDefault();
            const rect = imageViewArea.getBoundingClientRect();
            const point = e.touches ? e.touches[0] : e;
            const currentX = point.clientX - rect.left;
            const currentY = point.clientY - rect.top;
            const width = currentX - selectionRect.startX;
            const height = currentY - selectionRect.startY;

            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            selectionCtx.strokeStyle = 'red';
            selectionCtx.lineWidth = 2;
            selectionCtx.strokeRect(selectionRect.startX, selectionRect.startY, width, height);
        }

        async function onSelectionUp(e) {
            if (!isSelecting) return; // Prevent re-triggering
            isSelecting = false;
            window.removeEventListener('mousemove', onSelectionMove);
            window.removeEventListener('touchmove', onSelectionMove);
            
            selectionCanvas.style.display = 'none';
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            
            const rect = imageViewArea.getBoundingClientRect();
            const point = e.changedTouches ? e.changedTouches[0] : e;
            const selectionEndX = point.clientX - rect.left;
            const selectionEndY = point.clientY - rect.top;

            const selX = Math.min(selectionRect.startX, selectionEndX);
            const selY = Math.min(selectionRect.startY, selectionEndY);
            const selW = Math.abs(selectionRect.startX - selectionEndX);
            const selH = Math.abs(selectionRect.startY - selectionEndY);

            if (selW < 10 || selH < 10) return;

            // --- OCR FIX START ---
            // Calculate scaling and offsets of the previewed image relative to its container
            const naturalW = imagePreview.naturalWidth;
            const naturalH = imagePreview.naturalHeight;
            const containerW = imageViewArea.clientWidth;
            const containerH = imageViewArea.clientHeight;
            const imgAspect = naturalW / naturalH;
            const contAspect = containerW / containerH;
            let renderedW, renderedH;

            if (imgAspect > contAspect) {
                renderedW = containerW;
                renderedH = containerW / imgAspect;
            } else {
                renderedH = containerH;
                renderedW = containerH * imgAspect;
            }

            const offsetX = (containerW - renderedW) / 2;
            const offsetY = (containerH - renderedH) / 2;
            const scaleFactor = naturalW / renderedW;

            // Translate selection coordinates from preview space to original image space
            const sourceX = (selX - offsetX) * scaleFactor;
            const sourceY = (selY - offsetY) * scaleFactor;
            const sourceWidth = selW * scaleFactor;
            const sourceHeight = selH * scaleFactor;
            
            // Check if selection is within the actual image bounds
            if (sourceX < 0 || sourceY < 0 || sourceX + sourceWidth > naturalW || sourceY + sourceHeight > naturalH) {
                updateStatus("Selection was outside the image area.", true);
                isProcessingOCR = false; 
                return;
            }

            const cropCanvas = document.createElement('canvas');
            const cropCtx = cropCanvas.getContext('2d');
            cropCanvas.width = sourceWidth;
            cropCanvas.height = sourceHeight;

            // Draw the selected part from the FULL RESOLUTION image for OCR
            cropCtx.drawImage(imagePreview, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);
            // --- OCR FIX END ---

            isProcessingOCR = true;
            updateStatus("Running OCR on selected area...");
            try {
                const { data: { text } } = await Tesseract.recognize(cropCanvas, 'eng');
                const ocrText = text.trim().replace(/\s+/g, '');
                if (ocrText) {
                    if (currentUploadType === 'MultiBox' && awbInput.disabled) {
                        remarkInput.value = ocrText;
                    } else if (currentUploadType === 'Product') {
                        docNumberInput.value = ocrText;
                    } else {
                        awbInput.value = ocrText;
                    }
                    updateStatus(`OCR successful: "${ocrText}"`);
                } else {
                    updateStatus("OCR could not find any text in the selected area.");
                }
            } catch (err) {
                updateStatus("OCR failed on selection.", true);
            } finally {
                // Add a small delay before allowing another OCR operation
                setTimeout(() => { isProcessingOCR = false; }, 300);
            }
        }

        imageViewArea.addEventListener('mousedown', onSelectionStart);
        imageViewArea.addEventListener('touchstart', onSelectionStart, { passive: false });
        
        async function handleVideoStreamClick() {
            if (!stream) return;

            if (imageQueue.length >= MAX_FILES) {
                updateStatus(`Maximum of ${MAX_FILES} images reached.`, true);
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = cameraFeed.videoWidth;
            canvas.height = cameraFeed.videoHeight;
            canvas.getContext('2d').drawImage(cameraFeed, 0, 0);
            const dataUrl = canvas.toDataURL('image/png');
            const newFile = await dataURLtoFile(dataUrl, `capture-${Date.now()}.png`);

            imageQueue.push(newFile);
            scrollerContainer.style.display = 'block';
            renderScroller();
            updateStatus(`${imageQueue.length} image(s) captured.`);
            
            // Update cancel button to "Done"
            if (cancelBtn.textContent !== 'Done') {
                cancelBtn.textContent = 'Done';
                cancelBtn.style.backgroundColor = '#28a745';
                cancelBtn.style.borderColor = '#28a745';
                cancelBtn.style.color = 'white';
            }
        }

        function getDefaultRemark(uploadType) {
            switch (uploadType) {
                case 'Reciept': return 'Booked';
                default: return 'Delivered'; // Covers POD
            }
        }

        pickBtn.addEventListener('click', async () => {
            if (!imagePreview.src) {
                updateStatus("No image to pick.", true);
                return;
            }
            const awbValue = awbInput.value.trim();

            if (awbValue === '') {
                updateStatus("Please enter AWB / Ref / KYC Number.", true);
                awbInput.focus();
                return;
            }
            if (/\s/.test(awbValue)) {
                updateStatus("AWB / Ref / KYC Number cannot contain spaces.", true);
                awbInput.focus();
                return;
            }
            if (isDuplicateEntry()) {
                return; // Stop if a duplicate is found based on the new rules
            }
            if (tableBody.rows.length >= MAX_ROWS) {
                updateStatus("Table is full.", true);
                return;
            }

            const rotatedImageSrc = await getRotatedImage(imagePreview.src, currentRotation);
            const finalImageSrc = await compressImage(rotatedImageSrc, 100, 1024);

            let rowData = [];
            if (currentUploadType === 'KYC') {
                const customerName = customerNameInput.value.trim();
                if (!customerName) {
                    updateStatus("Customer name is required for KYC.", true);
                    customerNameInput.focus();
                    return;
                }
                const kycType = kycTypeSelect.value;
                rowData = [ tableBody.rows.length + 1, awbValue, customerName, kycType, currentUploadType ];
            } else if (currentUploadType === 'Product') {
                 const docNumber = docNumberInput.value.trim();
                 if (!docNumber) {
                     updateStatus("Doc Number is required for Product.", true);
                     docNumberInput.focus();
                     return;
                 }
                rowData = [ tableBody.rows.length + 1, awbValue, docTypeSelect.value, docNumber, currentUploadType ];
            } else {
                 let remarkValue;
                if (currentUploadType === 'MultiBox') {
                    remarkValue = remarkInput.value.trim() || awbValue; // Default to awbValue if empty
                } else {
                    remarkValue = remarkInput.value.trim() || getDefaultRemark(currentUploadType);
                }
                rowData = [ tableBody.rows.length + 1, awbValue, remarkValue, currentUploadType ];
            }

            const newRow = tableBody.insertRow();
            rowData.forEach(text => {
                newRow.insertCell().textContent = text;
            });

            const imageCell = newRow.insertCell();
            const thumb = document.createElement('img');
            thumb.src = finalImageSrc;
            const cellDiv = document.createElement('div');
            cellDiv.className = 'image-cell-content';
            cellDiv.appendChild(thumb);
            imageCell.appendChild(cellDiv);
            
            // Lock AWB for product or multibox after first pick
            if ((currentUploadType === 'Product' || currentUploadType === 'MultiBox') && !isAwbLockedForProduct) {
                isAwbLockedForProduct = true;
                awbInput.disabled = true;
            }

            // Lock Customer Name for KYC after first pick
            if (currentUploadType === 'KYC' && !isCustomerNameLockedForKyc) {
                isCustomerNameLockedForKyc = true;
                customerNameInput.disabled = true;
            }

            awbInput.value = isAwbLockedForProduct ? awbInput.value : '';
            remarkInput.value = '';
            customerNameInput.value = isCustomerNameLockedForKyc ? customerNameInput.value : '';
            docNumberInput.value = '';


            if (!isImageLocked) {
                if (imageQueue.length > 0) {
                    imageQueue.splice(currentImageIndex, 1);
                    renderScroller();
                    displayImage(currentImageIndex < imageQueue.length ? currentImageIndex : 0);
                } else {
                    resetUploader();
                }
            } else {
                if(currentUploadType === 'Product') docNumberInput.focus();
                else if(currentUploadType === 'MultiBox') remarkInput.focus();
                else awbInput.focus();
            }
        });
        
        // --- Table & Utility Functions ---
        function isDuplicateEntry() {
            const rows = tableBody.rows;
            const awbValue = awbInput.value.trim();
            
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                switch (currentUploadType) {
                    case 'POD':
                    case 'Reciept':
                        if (row.cells[1].textContent === awbValue) {
                            updateStatus(`Duplicate AWB / Ref found: ${awbValue}`, true);
                            awbInput.focus();
                            return true;
                        }
                        break;
                    case 'KYC':
                         if (row.cells[1].textContent === awbValue) { // awbInput holds KYC number
                            updateStatus(`Duplicate KYC Number found: ${awbValue}`, true);
                            awbInput.focus();
                            return true;
                        }
                        break;
                    case 'Product':
                        const docNumber = docNumberInput.value.trim();
                        if (docNumber && row.cells[3].textContent === docNumber) {
                            updateStatus(`Duplicate Doc Number found: ${docNumber}`, true);
                            docNumberInput.focus();
                            return true;
                        }
                        break;
                    case 'MultiBox':
                        const childAwb = remarkInput.value.trim();
                        // Check only if childAwb is entered and is not the same as the parent AWB
                        if (childAwb && childAwb !== awbValue && row.cells[2].textContent === childAwb) {
                             updateStatus(`Duplicate Child Awb found: ${childAwb}`, true);
                             remarkInput.focus();
                             return true;
                        }
                        break;
                }
            }
            return false;
        }

        deleteLastBtn.addEventListener('click', () => { if (tableBody.rows.length > 0) tableBody.deleteRow(-1); });
        clearAllBtn.addEventListener('click', () => { 
            tableBody.innerHTML = ''; 
            if (currentUploadType === 'Product' || currentUploadType === 'MultiBox') {
                isAwbLockedForProduct = false;
                awbInput.disabled = false;
                awbInput.value = '';
            }
            if (currentUploadType === 'KYC') {
                isCustomerNameLockedForKyc = false;
                customerNameInput.disabled = false;
                customerNameInput.value = '';
                awbInput.value = '';
            }
        });
        
        submitBtn.addEventListener('click', async () => {
            const rows = tableBody.rows;
            const gscriptUrl = gscriptUrlInput.value.trim();

            if (rows.length === 0) {
                updateStatus("No data in the table to submit.", true);
                return;
            }
            if (!gscriptUrl || !gscriptUrl.startsWith('https://script.google.com/macros/s/')) {
                updateStatus("Please provide a valid Google Apps Script Web App URL.", true);
                gscriptUrlInput.focus();
                return;
            }

            submitBtn.disabled = true;
            let successCount = 0;
            
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                updateStatus(`Submitting row ${i + 1} of ${rows.length}...`);

                const rowUploadType = row.cells[row.cells.length - 2].textContent;
                const imgElement = row.cells[row.cells.length - 1].querySelector('img');
                if (!imgElement) continue;

                const rowData = {};
                rowData.uploadType = rowUploadType;
                
                if (rowUploadType === 'KYC') {
                    rowData.kycNumber = row.cells[1].textContent;
                    rowData.customerName = row.cells[2].textContent;
                    rowData.kycType = row.cells[3].textContent;
                } else if (rowUploadType === 'Product') {
                    rowData.awbNumber = row.cells[1].textContent;
                    rowData.docType = row.cells[2].textContent;
                    rowData.docNumber = row.cells[3].textContent;
                } else if (rowUploadType === 'MultiBox') {
                    rowData.awbNumber = row.cells[1].textContent;
                    rowData.childAwb = row.cells[2].textContent; 
                } else { // Covers POD, Reciept
                    rowData.awbNumber = row.cells[1].textContent;
                    rowData.statusRemark = row.cells[2].textContent;
                }

                const payload = {
                    imageData: imgElement.src,
                    fileName: `${rowData.awbNumber || rowData.kycNumber || rowData.docNumber}-${Date.now()}.jpg`,
                    rowData: rowData,
                };
                
                try {
                    const response = await fetch(gscriptUrl, {
                        method: 'POST',
                        body: JSON.stringify(payload),
                        headers: { 'Content-Type': 'text/plain;charset=utf-8' }, // Required for Apps Script
                        mode: 'cors',
                    });

                    const result = await response.json();
                    
                    if (result.status === 'success') {
                        successCount++;
                         row.style.backgroundColor = '#d4edda'; // Mark as successful
                    } else {
                        throw new Error(result.message);
                    }
                } catch (error) {
                    console.error('Submission error:', error);
                    row.style.backgroundColor = '#f8d7da'; // Mark as failed
                    updateStatus(`Error submitting row ${i + 1}: ${error.message}`, true);
                    submitBtn.disabled = false;
                    return; // Stop on first error
                }
            }

            updateStatus(`Successfully submitted ${successCount} of ${rows.length} rows.`, false);
            setTimeout(() => {
                clearAllBtn.click();
                 updateStatus('All data submitted and table cleared.');
            }, 2000);
            submitBtn.disabled = false;
        });

        async function dataURLtoFile(dataUrl, fileName) {
            const res = await fetch(dataUrl); const blob = await res.blob();
            return new File([blob], fileName, { type: 'image/jpeg' });
        }
        
        function getRotatedImage(src, rotation) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'), angle = rotation * Math.PI / 180;
                    if (rotation % 180 !== 0) { canvas.width = img.height; canvas.height = img.width; } 
                    else { canvas.width = img.width; canvas.height = img.height; }
                    ctx.translate(canvas.width / 2, canvas.height / 2); ctx.rotate(angle);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    resolve(canvas.toDataURL('image/png')); // Output high quality PNG for further compression
                };
                img.src = src;
            });
        }
        
        // --- Image Enhancement Logic ---
        let currentEnhancements = {
            brightness: 0,
            contrast: 0,
            sharpen: false,
            greyscale: false,
            bw: false,
        };

        enhanceBtn.addEventListener('click', () => {
            enhancementControls.style.display = enhancementControls.style.display === 'block' ? 'none' : 'block';
        });

        function resetEnhancements() {
            if (!cropper) return;
            updateStatus("Resetting enhancements...");
            
            currentEnhancements = { brightness: 0, contrast: 0, sharpen: false, greyscale: false, bw: false };
            
            brightnessSlider.value = 0;
            contrastSlider.value = 0;

            sharpenBtn.style.backgroundColor = '';
            greyscaleBtn.style.backgroundColor = '';
            bwBtn.style.backgroundColor = '';

            cropper.replace(originalCropperSrc);
            updateStatus("Enhancements reset.");
        }

        function applyEnhancements() {
            if (!cropper || !originalCropperSrc) return;
            updateStatus("Applying enhancements...");

            const tempCanvas = document.createElement('canvas');
            const tempImg = new Image();
            tempImg.crossOrigin = "Anonymous";
            tempImg.onload = () => {
                tempCanvas.width = tempImg.width;
                tempCanvas.height = tempImg.height;
                tempCanvas.getContext('2d').drawImage(tempImg, 0, 0);

                Caman(tempCanvas, function () {
                    this.revert(false);

                    if (currentEnhancements.bw) {
                        this.greyscale().contrast(70).brightness(5);
                    } else if (currentEnhancements.greyscale) {
                        this.greyscale();
                    }
                    if (currentEnhancements.sharpen) {
                        this.sharpen(10);
                    }
                    this.brightness(parseInt(currentEnhancements.brightness, 10));
                    this.contrast(parseInt(currentEnhancements.contrast, 10));

                    this.render(() => {
                        const newDataUrl = this.toBase64();
                        cropper.replace(newDataUrl);
                        updateStatus('Enhancements applied.');
                    });
                });
            };
            tempImg.src = originalCropperSrc;
        }

        resetEnhanceBtn.addEventListener('click', resetEnhancements);
        brightnessSlider.addEventListener('input', () => { currentEnhancements.brightness = brightnessSlider.value; applyEnhancements(); });
        contrastSlider.addEventListener('input', () => { currentEnhancements.contrast = contrastSlider.value; applyEnhancements(); });
        sharpenBtn.addEventListener('click', () => { currentEnhancements.sharpen = !currentEnhancements.sharpen; sharpenBtn.style.backgroundColor = currentEnhancements.sharpen ? '#d4edda' : ''; applyEnhancements(); });
        greyscaleBtn.addEventListener('click', () => {
            currentEnhancements.greyscale = !currentEnhancements.greyscale;
            if (currentEnhancements.greyscale) { currentEnhancements.bw = false; bwBtn.style.backgroundColor = ''; }
            greyscaleBtn.style.backgroundColor = currentEnhancements.greyscale ? '#d4edda' : ''; applyEnhancements();
        });
        bwBtn.addEventListener('click', () => {
            currentEnhancements.bw = !currentEnhancements.bw;
            if (currentEnhancements.bw) { currentEnhancements.greyscale = false; greyscaleBtn.style.backgroundColor = ''; }
            bwBtn.style.backgroundColor = currentEnhancements.bw ? '#d4edda' : ''; applyEnhancements();
        });
        autoEnhanceBtn.addEventListener('click', () => {
            currentEnhancements.sharpen = true;
            currentEnhancements.brightness = 10;
            currentEnhancements.contrast = 10;
            currentEnhancements.greyscale = false;
            currentEnhancements.bw = false;
            brightnessSlider.value = currentEnhancements.brightness;
            contrastSlider.value = currentEnhancements.contrast;
            sharpenBtn.style.backgroundColor = '#d4edda';
            greyscaleBtn.style.backgroundColor = '';
            bwBtn.style.backgroundColor = '';
            applyEnhancements();
        });

        // --- Keyboard Navigation ---
        const inputFields = [
            awbInput,
            customerNameInput,
            kycTypeSelect,
            docTypeSelect,
            docNumberInput,
            remarkInput
        ];

        function handleEnterKey(e) {
            if (e.key !== 'Enter') return;
            e.preventDefault();

            const currentField = e.target;
            const isRequiredAndEmpty = (field) => {
                if (!field || field.style.display === 'none' || field.disabled) return false; // Added null check

                const value = field.value.trim();
                if (value === '') {
                    if (field === awbInput) return true;
                    if (field === customerNameInput && currentUploadType === 'KYC') return true;
                    if (field === docNumberInput && currentUploadType === 'Product') return true;
                }
                return false;
            };

            if (isRequiredAndEmpty(currentField)) {
                let fieldName = "This field";
                if(currentField.placeholder) fieldName = currentField.placeholder.replace('(Required)','').trim();
                updateStatus(`${fieldName} is a required field.`, true);
                return; // Stop navigation
            }


            const visibleFields = inputFields.filter(field => field && field.style.display !== 'none' && !field.disabled); // Added null check
            const currentIndex = visibleFields.indexOf(e.target);

            if (currentIndex > -1 && currentIndex < visibleFields.length - 1) {
                // If it's not the last visible field, focus the next one
                visibleFields[currentIndex + 1].focus();
            } else {
                // If it's the last visible field or not in the list, click the pick button
                pickBtn.click();
            }
        }

        inputFields.forEach(field => {
             if (field) { // Added null check before adding listener
                 field.addEventListener('keydown', handleEnterKey);
            }
        });

        // Initialize UI for the default type
        updateUIForUploadType(currentUploadType);
        
        // --- NEW/MODIFIED LOGIC FOR SIDEBAR & DATA INTEGRATION ---

        // State Variables
        let allOrders = [];
        let allClientsB2B = [];
        let allClientsB2B2C = [];
        let allProducts = []; 
        let isOrderListCollapsed = false; 

        // UI Elements (specific to sidebar/list)
        const ui = {
            orderListContainer: document.getElementById('orderListContainer'),
            uploaderFormContainer: document.getElementById('uploaderFormContainer'),
            orderList: document.getElementById('orderList'),
            searchOrderInput: document.getElementById('searchOrder'),
            newOrderBtn: document.getElementById('newOrderBtn'),
            backToListBtn: document.getElementById('backToListBtn'),
            awbInput: document.getElementById('awb-input'), // Already defined above, reusing
            customerNameInput: document.getElementById('customer-name-input'), // Already defined
            customerDataList: document.getElementById('customer-list'),
            docNumberInput: document.getElementById('doc-number-input'), // Already defined
            docNumberDataList: document.getElementById('doc-number-list'),
            toggleOrderListBtn: document.getElementById('toggleOrderListBtn'), 
            collapseIcon: document.getElementById('collapseIcon'), 
            expandIcon: document.getElementById('expandIcon') 
        };
        
        // View Logic (for mobile and sidebar collapse) 
        const isMobileView = () => window.innerWidth < 768;

        const toggleSidebar = (collapse) => {
             isOrderListCollapsed = collapse;
             ui.orderListContainer.classList.toggle('collapsed', isOrderListCollapsed);
             ui.uploaderFormContainer.classList.toggle('expanded', isOrderListCollapsed);
             ui.collapseIcon.classList.toggle('hidden', isOrderListCollapsed);
             ui.expandIcon.classList.toggle('hidden', !isOrderListCollapsed);

             if (isMobileView()) {
                 if (isOrderListCollapsed) {
                     ui.orderListContainer.classList.add('hidden'); 
                     ui.uploaderFormContainer.classList.remove('hidden');
                     ui.uploaderFormContainer.classList.add('block'); 
                     ui.uploaderFormContainer.classList.remove('md:block');
                 } else {
                     ui.orderListContainer.classList.remove('hidden'); 
                     ui.uploaderFormContainer.classList.add('hidden');
                     ui.uploaderFormContainer.classList.remove('block'); 
                     ui.uploaderFormContainer.classList.add('md:block'); 
                 }
             } else {
                  ui.orderListContainer.classList.remove('hidden');
                  ui.uploaderFormContainer.classList.remove('hidden');
                  ui.uploaderFormContainer.classList.remove('block');
                  ui.uploaderFormContainer.classList.add('md:block');
             }

            setTimeout(() => {
                if (cropper) cropper.resize();
                drawPreview(); 
            }, 350); 
        };
        
         const showFormView = () => {
             if (isMobileView()) {
                 toggleSidebar(true); 
             }
         };

         const showListView = () => {
             if (isMobileView()) {
                 toggleSidebar(false); 
             }
             else if (isOrderListCollapsed) {
                 toggleSidebar(false);
             }
         };

        const handleResize = () => {
            if (!isMobileView()) {
                ui.orderListContainer.classList.remove('hidden'); 
                ui.uploaderFormContainer.classList.remove('hidden', 'block');
                ui.uploaderFormContainer.classList.add('md:block');
                ui.orderListContainer.classList.toggle('collapsed', isOrderListCollapsed);
                ui.uploaderFormContainer.classList.toggle('expanded', isOrderListCollapsed);
            } else {
                if (!ui.uploaderFormContainer.classList.contains('hidden')) { 
                    ui.orderListContainer.classList.add('hidden');
                    ui.uploaderFormContainer.classList.add('block');
                    ui.uploaderFormContainer.classList.remove('md:block');
                    isOrderListCollapsed = true; 
                } else { 
                    ui.orderListContainer.classList.remove('hidden');
                    ui.uploaderFormContainer.classList.add('hidden');
                    ui.uploaderFormContainer.classList.remove('block');
                    ui.uploaderFormContainer.classList.add('md:block');
                     isOrderListCollapsed = false; 
                }
                ui.collapseIcon.classList.toggle('hidden', isOrderListCollapsed);
                ui.expandIcon.classList.toggle('hidden', !isOrderListCollapsed);
            }
             // Ensure redraw happens after potential layout shifts
             setTimeout(() => {
                 if (cropper) cropper.resize();
                 drawPreview(); 
             }, 50); // Small delay might be sufficient
        };
        window.addEventListener('resize', handleResize);
        
        // Data Loading 
        const handleDataLoaded = (event) => {
             console.log("handleDataLoaded triggered in uploader.html", event.detail); // Debug log
            if (!event.detail || !event.detail.data) {
                document.getElementById('orderLoader').textContent = 'No data found.';
                 console.warn("No data in event detail.");
                return;
            };
            
            const appData = event.detail.data;
            
            allOrders = appData.ORDERS || [];
            console.log("Orders loaded:", allOrders.length); // Debug log
            if (allOrders.length > 0) {
                 renderOrderList(allOrders);
            } else {
                 document.getElementById('orderLoader').textContent = 'No orders found.';
            }

            allClientsB2B = appData.B2B || []; 
            allClientsB2B2C = appData.B2B2C || []; 
            console.log("Clients loaded:", allClientsB2B.length, "B2B,", allClientsB2B2C.length, "B2B2C"); // Debug log

            allProducts = appData.PRODUCT || []; 
            console.log("Products loaded:", allProducts.length); // Debug log
        };
        
        window.addEventListener('appDataLoaded', handleDataLoaded);
        window.addEventListener('appDataRefreshed', handleDataLoaded);
        
        // List Rendering 
        const renderOrderList = (orders) => {
            ui.orderList.innerHTML = '';
            if (!orders || orders.length === 0) {
                ui.orderList.innerHTML = '<li class="text-center text-gray-500">No matching orders.</li>';
                return;
            }
            orders.forEach(order => {
                const ref = order.REFERANCE;
                 if (!ref) { // Skip if REFERANCE is missing
                    console.warn("Order missing REFERANCE:", order);
                    return; 
                }
                const displayAwb = order.AWB_NUMBER || ref;
                
                // Find client name based on CODE
                let clientName = 'Unknown Client';
                const parentClient = allClientsB2B.find(c => c.CODE === order.CODE);
                if (parentClient) {
                    clientName = parentClient.CLIENT_NAME || clientName;
                } else {
                    // Fallback to searching B2B2C if not found in B2B (less likely for order CODE)
                    const childClient = allClientsB2B2C.find(c => c.CODE === order.CODE);
                    if (childClient) {
                         clientName = childClient.NAME || clientName; // Use NAME for B2B2C
                    }
                }

                const li = document.createElement('li');
                li.className = 'p-3 rounded-lg cursor-pointer hover:bg-indigo-50 transition-colors border border-gray-200';
                 li.innerHTML = `<strong class="text-indigo-700 block text-sm">${displayAwb}</strong><span class="text-xs text-gray-600">${clientName} (Ref: ${ref})</span>`;
                li.dataset.orderRef = ref;
                li.addEventListener('click', () => selectOrder(ref));
                ui.orderList.appendChild(li);
            });
             document.getElementById('orderLoader').textContent = ''; // Clear loading message
        };

        // Core Selection Logic 
        const selectOrder = (orderRef) => {
            console.log("Selecting order:", orderRef); // Debug log
            const order = allOrders.find(o => o.REFERANCE === orderRef);
             if (!order) {
                console.warn("Order not found for ref:", orderRef);
                return;
            }
            
            ui.awbInput.value = order.AWB_NUMBER || order.REFERANCE || '';
            populateKycData(order);
            populateProductData(order);
            toggleSidebar(true); 
        };

        const populateKycData = (order) => {
            ui.customerDataList.innerHTML = '';
            const clientCode = order.CODE; 
            if (!clientCode) return;

            const parentClient = allClientsB2B.find(c => c.CODE === clientCode);
            if (parentClient && parentClient.CLIENT_NAME) {
                const option = document.createElement('option');
                option.value = parentClient.CLIENT_NAME;
                ui.customerDataList.appendChild(option);
            }
            
            const childClients = allClientsB2B2C.filter(c => c.CODE === clientCode);
            childClients.forEach(client => {
                if (client.NAME) { 
                    const option = document.createElement('option');
                    option.value = client.NAME; 
                    ui.customerDataList.appendChild(option);
                }
            });
             console.log("Populated KYC datalist with", ui.customerDataList.options.length, "options for CODE:", clientCode); // Debug log
        };

        const populateProductData = (order) => {
            ui.docNumberDataList.innerHTML = '';
            const orderRef = order.REFERANCE;
            
            // Use 'RERERANCE' based on provided appData structure
            const productsForOrder = allProducts.filter(p => p.RERERANCE === orderRef); 
            
            productsForOrder.forEach(product => {
                if (product.DOC_NUMBER) { 
                    const option = document.createElement('option');
                    option.value = product.DOC_NUMBER; 
                    ui.docNumberDataList.appendChild(option);
                }
            });
             console.log("Populated Product datalist with", ui.docNumberDataList.options.length, "options for REFERANCE:", orderRef); // Debug log
        };

        // Event Listeners for List/Form 
        ui.searchOrderInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const filteredOrders = allOrders.filter(order => {
                let clientName = '';
                const parentClient = allClientsB2B.find(c => c.CODE === order.CODE);
                 if (parentClient) clientName = parentClient.CLIENT_NAME || '';
                
                return (order.REFERANCE ? String(order.REFERANCE).toLowerCase().includes(searchTerm) : false) || 
                       (order.AWB_NUMBER ? String(order.AWB_NUMBER).toLowerCase().includes(searchTerm) : false) ||
                       (clientName ? clientName.toLowerCase().includes(searchTerm) : false) ||
                       (order.CODE ? order.CODE.toLowerCase().includes(searchTerm) : false);
            });
            renderOrderList(filteredOrders);
        });

        ui.newOrderBtn.addEventListener('click', () => {
            ui.awbInput.value = '';
            ui.customerNameInput.value = '';
            ui.docNumberInput.value = '';
            ui.customerDataList.innerHTML = '';
            ui.docNumberDataList.innerHTML = '';
            toggleSidebar(true); 
        });
        
        ui.backToListBtn.addEventListener('click', () => {
             toggleSidebar(false); 
        });

        ui.toggleOrderListBtn.addEventListener('click', () => {
            toggleSidebar(!isOrderListCollapsed); 
        });
        
        // MODIFIED: Original Functions 
        const originalResetUploader = resetUploader; 
        resetUploader = () => {
            originalResetUploader(); 
            if (isOrderListCollapsed && !isMobileView()) { // Only expand on desktop if collapsed
                 toggleSidebar(false); 
            } else if (isMobileView()){
                 showListView(); 
            }
             // Clear potentially filled fields if reset is called manually
            ui.awbInput.value = '';
            ui.customerNameInput.value = '';
            ui.docNumberInput.value = '';
            ui.customerDataList.innerHTML = '';
            ui.docNumberDataList.innerHTML = '';
        };

        // Initial Data Load from Cache 
        const appDataJSON = localStorage.getItem('appData');
        if (appDataJSON) {
            try {
                const appData = JSON.parse(appDataJSON);
                 console.log("Loading initial data from cache."); // Debug log
                if (appData.data) {
                    handleDataLoaded({ detail: appData }); // Pass the whole object
                } else {
                     document.getElementById('orderLoader').textContent = 'Could not parse data from cache.';
                     console.warn("Cached appData missing 'data' property.");
                }
            } catch (e) {
                 document.getElementById('orderLoader').textContent = 'Error loading data from cache.';
                 console.error("Error parsing cached appData:", e);
            }
        } else {
             document.getElementById('orderLoader').textContent = 'Waiting for data...';
             console.log("No appData found in cache."); // Debug log
        }
        
        // Initialize the view state
        handleResize(); 

    </script>
</body>
</html>

