<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uploader V3 (80/20 Layout)</title>
    
    <!-- Google Fonts & Tailwind CSS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Cropper.js CSS (from V1) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
    
    <style>
        /* Basic Reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent body scroll */
        }

        /* Main Container */
        .main-container {
            display: flex;
            height: 100vh; /* Full viewport height */
            width: 100%;
        }

        /* Left Panel - 80% */
        .left-panel {
            flex: 0 0 80%;
            max-width: 80%;
            background-color: #ffffff; /* Was f0f0f0 */
            overflow-y: auto; /* Adds scrollbar if content is too long */
        }

        /* Right Panel - 20% */
        .right-panel {
            flex: 0 0 20%;
            max-width: 20%;
            background-color: #f7fafc; /* Was e0e0e0 */
            border-left: 1px solid #e2e8f0; /* Optional divider */
            overflow-y: auto;
            display: flex;
            flex-direction: column; /* To make list scrollable */
        }

        /* --- STYLES FROM V1 (Controls Banner) --- */
        #main-controls-strip {
            width: 100%; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            gap: 10px; 
            flex-wrap: wrap; 
            padding: 8px; 
            background-color: #e9ecef;
            box-sizing: border-box;
        }
        .upload-type-strip, .button-group {
            display: flex; 
            flex-wrap: wrap; 
            gap: 8px;
            align-items: center; 
            justify-content: center;
        }
        .separator { 
            width: 1px; 
            height: 28px; 
            background-color: #ced4da; 
        }
        @media (max-width: 680px) { .separator { display: none; } }
        
        /* Using a generic class for all V1 buttons */
        .v1-btn {
            padding: 8px 16px; 
            border: 1px solid #ccc; 
            background-color: #fff; 
            border-radius: 4px;
            cursor: pointer; 
            font-weight: 500; 
            color: #333; 
            transition: background-color 0.2s, border-color 0.2s;
            font-size: 0.875rem; /* 14px */
        }
        .v1-btn:hover { 
            background-color: #f0f0f0; 
            border-color: #bbb; 
        }
        .v1-btn:disabled { 
            background-color: #e9ecef; 
            cursor: not-allowed; 
            opacity: 0.7; 
        }
        
        .type-btn { padding: 6px 12px; }
        .type-btn.active {
            background-color: #1E3A8A; 
            color: #fff; 
            border-color: #1E3A8A; 
            font-weight: bold;
        }
        .type-btn.active:hover { 
            background-color: #1c347a; 
        }
        /* --- END V1 BANNER STYLES --- */
        
        /* --- STYLES FOR V1 IMAGE COMPONENTS --- */
        #image-scroller-container {
            width: 100%; 
            height: 80px; 
            background-color: #eee; 
            border: 1px solid #ddd;
            border-radius: 4px; 
            padding: 5px; 
            box-sizing: border-box; 
            display: none; /* Hidden by default */
            margin-bottom: 15px;
        }
        #image-scroller { 
            height: 100%; 
            display: flex; 
            gap: 5px; 
            overflow-x: auto; 
            white-space: nowrap; 
        }
        .scroller-img {
            height: 100%; 
            width: 70px; 
            object-fit: cover; 
            cursor: pointer;
            border: 2px solid transparent; 
            border-radius: 2px; 
            transition: border-color 0.2s;
        }
        .scroller-img.active { 
            border-color: #1E3A8A; 
        }

        #image-view-area {
            border: 2px dashed #ccc; 
            width: 100%; 
            aspect-ratio: 4 / 3; 
            display: flex;
            justify-content: center; 
            align-items: center; 
            text-align: center; 
            color: #888;
            position: relative; 
            overflow: hidden; 
            background-color: #f0f0f0;
            cursor: default;
        }
        #image-view-area.selectable { 
            cursor: crosshair; 
        }
        
        /* Preview elements inside the view area */
        #image-preview { display: none; } /* <<< THIS IS THE FIX. It should always be hidden. */
        #camera-feed, #preview-canvas { 
            width: 100%; 
            height: 100%; 
            object-fit: contain; 
        }
        #camera-feed.active-capture { 
            cursor: pointer; 
        }
        #preview-canvas { 
            display: none; 
        }
        #selection-canvas {
            position: absolute; 
            top: 0; 
            left: 0; 
            display: none; 
            z-index: 10;
        }

        /* Inline Cropper styles */
        #inline-cropper-wrapper {
            display: none; /* Hidden by default */
            width: 100%; 
            padding: 10px; 
            box-sizing: border-box;
            background-color: #f0f0f0; 
            border: 2px dashed #1E3A8A; 
        }
        #cropper-container { 
            width: 100%; 
            height: 60vh; /* 60% of viewport height */
        }
        #cropper-image { 
            display: block; 
            max-width: 100%; 
        }
        
        /* Enhancement styles */
        .slider-control { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            width: 100%; 
            max-width: 280px; 
            justify-content: center; 
        }
        .enhancement-sliders { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 10px; 
            margin-top: 15px; 
        }
        input[type="range"] { 
            flex-grow: 1; 
        }

        #status-bar {
            width: 100%; 
            padding: 8px; 
            box-sizing: border-box; 
            min-height: 2.5em;
            text-align: center; 
            background-color: #e9ecef; 
            border-radius: 4px; 
            color: #495057;
            margin-top: 15px; 
        }
        #status-bar.error { 
            color: #dc3545; 
            font-weight: bold; 
        }
        /* --- END OF V1 IMAGE STYLES --- */

        /* --- NEW: Dynamic Input Area Styles --- */
        #dynamic-input-area {
            width: 100%;
            margin-top: 15px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background-color: #fafafa;
            max-height: 280px; /* Limit height and allow scroll */
            overflow-y: auto;
        }
        /* Styles for the new table inside the dynamic area */
        .pickup-table {
            width: 100%;
            border-collapse: collapse;
        }
        .pickup-table th, .pickup-table td {
            padding: 10px;
            border-bottom: 1px solid #eee;
            font-size: 0.875rem; /* 14px */
            text-align: left;
            vertical-align: middle;
            white-space: normal; /* <-- ALLOW WRAPPING */
        }
        .pickup-table th {
            background-color: #f8f8f8;
            font-weight: 600;
            color: #333;
            position: sticky; /* Make headers sticky inside the scrollable container */
            top: 0;
            z-index: 1;
            white-space: nowrap; /* <-- PREVENT HEADER WRAPPING */
        }
        .pickup-table tr:last-child td {
            border-bottom: none;
        }
        
        /* NEW: Style for selected pickup row */
        .pickup-table tr:hover {
             background-color: #f0f4f8;
        }
        .pickup-table tr.selected-pickup-row {
            background-color: #e0e7ff; /* Lighter than order list selection */
            font-weight: 600;
        }

        /* Styles for inputs inside the table */
        .pickup-table input[type="text"],
        .pickup-table select {
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.875rem;
            background-color: #fff;
            width: 100%;
            min-width: 150px; /* Give inputs a minimum width */
        }
        .pickup-table .kyc-inputs {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .pickup-table .pick-btn-dynamic {
            padding: 6px 12px;
            font-size: 0.8rem; /* 12px */
            background-color: #d4edda;
            border-color: #c3e6cb;
        }
        
        #dynamic-input-area .placeholder {
            padding: 20px;
            text-align: center;
            color: #888;
            font-style: italic;
        }
        /* --- END Dynamic Input Styles --- */


        /* --- V1 Table Styles --- */
        .data-table-container { 
            width: 100%; 
            margin-top: 15px; 
            overflow-x: auto; 
            max-height: 400px; 
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        /* Make table rule specific */
        .data-table-container table { 
            width: 100%; 
            border-collapse: collapse; 
        }
        .data-table-container th, .data-table-container td { 
            border: 1px solid #ccc; 
            padding: 8px; 
            text-align: left; 
            font-size: 12px; 
            white-space: nowrap; /* <-- Keep nowrap ONLY for this table */
        }
        .data-table-container th { 
            background-color: #f0f0f0; 
            position: sticky; 
            top: 0;
            z-index: 2;
        }
        
        /* Bundled Table Headers (Restored) */
        .data-table-container th:nth-child(1) { width: 15%; } /* STATUS */
        .data-table-container th:nth-child(2) { width: 20%; } /* REF / AWB */
        .data-table-container th:nth-child(3) { width: 25%; } /* CUSTOMER / KYC */
        .data-table-container th:nth-child(4) { width: 20%; } /* DOC INFO */
        .data-table-container th:nth-child(5) { width: 10%; } /* IMAGE */

        .data-table-container td .image-cell-content { 
            width: 60px; 
            height: 40px; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
        }
        .data-table-container td .image-cell-content img { 
            max-width: 100%; 
            max-height: 100%; 
            object-fit: contain; 
        }
        #table-actions { 
            width: 100%; 
            margin-top: 15px; 
            display: flex;
            gap: 8px;
            justify-content: flex-end; 
        }
        /* --- END V1 TABLE STYLES --- */

        /* --- *** NEW: Existing Uploads Table Styles *** --- */
        #existing-uploads-container {
            display: none; /* Hidden by default */
            margin-top: 25px; /* More space */
            border-top: 2px solid #1E3A8A;
            padding-top: 10px;
        }
        #existing-uploads-container h3 {
            font-size: 1.125rem; /* 18px */
            font-weight: 600;
            margin-bottom: 10px;
            color: #1E3A8A;
        }
        /* Reuse the same container style */
        #existing-uploads-table {
            width: 100%; 
            margin-top: 5px; 
            overflow-x: auto; 
            max-height: 300px; 
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        /* --- *** END: Existing Uploads Table Styles *** --- */


        /* Right panel styles */
        .right-panel-header {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
            flex-shrink: 0; 
        }
        .right-panel-header input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.375rem;
            font-size: 0.9rem;
        }

        #miniOrderListContainer {
            flex-grow: 1; 
            overflow-y: auto;
            padding: 1rem;
        }
        #miniOrderList li {
            padding: 0.5rem 0.25rem;
            font-size: 0.875rem;
            cursor: pointer;
            border-radius: 0.25rem;
            margin-bottom: 0.25rem;
            white-space: normal;
            line-height: 1.4;
            border-bottom: 1px solid #eee;
        }
        #miniOrderList li:last-child { border-bottom: none; }
        #miniOrderList li:hover { background-color: #eef2ff; }
        /* NEW: Selected state for order list */
        #miniOrderList li.selected {
            background-color: #c7d2fe; /* Indigo-200 */
            font-weight: 600;
        }
        #miniOrderList li.selected strong {
            color: #312e81; /* Indigo-900 */
        }

        #miniOrderList li strong { color: #4338ca; display: block; margin-bottom: 2px; }
        #miniOrderList .client-info { font-size: 0.8rem; color: #6b7280; }
        #miniOrderList .details-info { font-size: 0.75rem; color: #4b5563; margin-top: 2px; }
        #miniOrderList .dest-info { font-size: 0.8rem; color: #374151; margin-top: 2px;}

        #loadMoreBtn {
            display: block;
            width: calc(100% - 2rem); 
            margin: 0 1rem 1rem 1rem; 
            text-align: center;
            padding: 6px;
            font-size: 0.8rem;
            color: #4f46e5;
            background-color: #eef2ff;
            border: 1px solid #c7d2fe;
            border-radius: 0.375rem;
            cursor: pointer;
            flex-shrink: 0; 
        }
        #loadMoreBtn:hover { background-color: #e0e7ff; }
        #loadMoreBtn:disabled { background-color: #f3f4f6; color: #9ca3af; cursor: not-allowed; }

        .status-message {
            padding: 1rem;
            text-align: center;
            color: #6b7280;
        }
    </style>
</head>
<body>

    <div class="main-container">
        <!-- 80% Left Panel -->
        <div class="left-panel">
            <!-- Main Controls Banner (from V1) -->
            <div id="main-controls-strip">
                <div class="upload-type-strip">
                    <!-- REMOVED 'active' class from POD button -->
                    <button class="type-btn v1-btn" data-type="POD">POD</button>
                    <button class="type-btn v1-btn" data-type="Reciept">Reciept</button>
                    <button class="type-btn v1-btn" data-type="KYC">KYC</button>
                    <button class="type-btn v1-btn" data-type="Product">Product</button>
                    <button class="type-btn v1-btn" data-type="MultiBox">MultiBox</button>
                </div>
                <div class="separator"></div>
                <div class="button-group">
                    <button id="camera-btn" class="v1-btn">Camera</button>
                    <button id="upload-btn" class="v1-btn">Upload</button>
                    <button id="rotate-btn" class="v1-btn">Rotate</button>
                    <button id="lock-btn" class="v1-btn">Lock</button>
                    <button id="cancel-btn" class="v1-btn">Cancel</button>
                    <button id="cancel-all-btn" class="v1-btn">Cancel All</button>
                    <input type="file" id="file-input" accept="image/*,application/pdf" multiple style="display: none;">
                </div>
            </div>

            <!-- Wrapper for future content, to restore padding -->
            <div class="p-5"> 

                <!-- *** NEW: Hidden input for GScript URL (from V1) *** -->
                <input type="hidden" id="gscript-url" value="https://script.google.com/macros/s/AKfycbwkC3OXNACPPH-LLPJyhkZKaDh6VtNgGbp8lMQbzz1XF327IN_OhFEEapOzNm3REbn5/exec">

                <!-- Image Scroller (from V1) -->
                <div id="image-scroller-container"><div id="image-scroller"></div></div>

                <!-- Inline Cropper (from V1) -->
                <div id="inline-cropper-wrapper">
                    <div id="cropper-container">
                        <img id="cropper-image" src="">
                    </div>
                    <div class="button-group" style="margin-top: 10px; display:flex; gap: 8px; justify-content: center;">
                        <button id="crop-rotate-btn" class="v1-btn">Rotate</button>
                        <button id="enhance-btn" class="v1-btn">Enhance</button>
                        <button id="crop-confirm-btn" class="v1-btn" style="background-color: #d4edda;">Crop</button>
                        <button id="crop-cancel-btn" class="v1-btn" style="background-color: #f8d7da;">Cancel</button>
                    </div>
                    <div id="enhancement-controls" style="display:none; margin-top:10px; padding-top:10px; border-top: 1px solid #ccc;">
                        <div class="button-group" style="display:flex; gap: 8px; justify-content: center;">
                             <button id="auto-enhance-btn" class="v1-btn">Auto</button>
                            <button id="greyscale-btn" class="v1-btn">Greyscale</button>
                            <button id="bw-btn" class="v1-btn">B&W Doc</button>
                            <button id="sharpen-btn" class="v1-btn">Sharpen</button>
                            <button id="reset-enhance-btn" class="v1-btn" style="background-color: #f8d7da;">Reset</button>
                        </div>
                        <div class="enhancement-sliders">
                            <div class="slider-control">
                                <label for="brightness-slider">Brightness</label>
                                <input type="range" id="brightness-slider" min="-50" max="50" value="0">
                            </div>
                            <div class="slider-control">
                                <label for="contrast-slider">Contrast</label>
                                <input type="range" id="contrast-slider" min="-50" max="50" value="0">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Preview Area (from V1) -->
                <div id="image-view-area">
                    <span id="placeholder">Select Camera or Upload to begin</span>
                    <img id="image-preview" src="" alt="Image preview"/>
                    <canvas id="preview-canvas"></canvas>
                    <canvas id="selection-canvas"></canvas>
                    <video id="camera-feed" autoplay playsinline></video>
                </div>

                <!-- Status Bar (from V1) -->
                <div id="status-bar">Initializing...</div>

                <!-- === NEW: Dynamic Input Area (Rebuilt as a Table) === -->
                <div id="dynamic-input-area">
                    <div class="placeholder">Select an order from the list...</div>
                    <!-- Table will be generated here by JS -->
                </div>
                <!-- === END: Dynamic Input Area === -->


                <!-- Data Table (from V1) -->
                <div class="data-table-container">
                    <table>
                        <thead>
                            <!-- MODIFIED: Headers RESTORED to bundled version -->
                            <tr id="table-header-row">
                                <th>STATUS</th>
                                <th>REFERENCE / AWB</th>
                                <th>CUSTOMER / KYC INFO</th>
                                <th>DOCUMENT INFO</th>
                                <th>IMAGE</th>
                                <th style="display: none;">BRANCH / CODE</th> <!-- HIDDEN HEADER -->
                            </tr>
                        </thead>
                        <tbody id="data-table-body">
                            <!-- Rows will be added here by JavaScript -->
                        </tbody>
                    </table>
                </div>

                <!-- Table Actions (from V1) -->
                <div id="table-actions">
                    <button id="delete-last-btn" class="v1-btn" style="background-color: #f8d7da;">Delete Last</button>
                    <button id="clear-all-btn" class="v1-btn" style="background-color: #f8d7da;">Clear All</button>
                    <button id="submit-btn" class="v1-btn" style="background-color: #d4edda; font-weight: bold;">Submit</button>
                </div>

                <!-- === *** NEW: Existing Uploads Section *** === -->
                <div id="existing-uploads-container">
                    <h3>Existing Uploads for this Order</h3>
                    <div id="existing-uploads-table" class="data-table-container">
                        <table>
                            <thead>
                                <tr id="existing-table-header-row">
                                    <th>STATUS</th>
                                    <th>REFERENCE / AWB</th>
                                    <th>CUSTOMER / KYC INFO</th>
                                    <th>DOCUMENT INFO</th>
                                    <th>IMAGE</th>
                                    <th style="display: none;">BRANCH / CODE</th> <!-- HIDDEN HEADER -->
                                </tr>
                            </thead>
                            <tbody id="existing-data-table-body">
                                <!-- Rows will be added here by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
                <!-- === *** END: Existing Uploads Section *** === -->


            </div>
        </div>

        <!-- 20% Right Panel (Shipment List) -->
        <div class="right-panel">
            <div class="right-panel-header">
                <input type="text" id="searchMiniOrder" placeholder="Filter orders..." class="w-full p-1 border border-gray-300 rounded-md text-sm">
            </div>
            
            <div id="miniOrderListContainer">
                <ul id="miniOrderList">
                    <li class="status-message">Loading orders...</li>
                </ul>
            </div>
            
            <button id="loadMoreBtn" style="display: none;">Load More (Older)</button>
        </div>
    </div>

    <!-- Third-party libraries (from V1) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/camanjs/4.1.2/caman.full.min.js"></script>
    <!-- *** NEW: jsPDF Library for creating PDFs *** -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        // Set up PDF.js worker (from V1)
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;

        // --- V2 State Variables (Shipment List) ---
        let allOrders = [];
        let displayedOrders = [];
        let allClientsB2B = [];
        let allClientsB2B2C = [];
        let allProducts = [];
        let allUploads = []; // *** NEW: To store existing uploads ***
        let displayDays = 90;
        let selectedOrder = null; // NEW: To track selected order
        let currentUploadType = null; // NEW: Default to null (no selection)

        // --- V1 State Variables (Uploader) ---
        let stream = null, currentRotation = 0, isImageLocked = false, cropper = null;
        let imageQueue = [], currentImageIndex = -1;
        let barcodeDetector;
        let originalCropperSrc = null;
        const MAX_FILES = 50;
        let isSelecting = false, selectionRect = {};
        let isProcessingOCR = false;
        let isProcessingImage = false; // *** NEW: Race condition lock ***
        let selectedPickupRow = null; // *** NEW: To track selected pickup row ***
        let selectionCtx, previewCtx;
        let currentEnhancements = { brightness: 0, contrast: 0, sharpen: false, greyscale: false, bw: false };

        // --- V2 UI Elements (Right Panel) ---
        let miniOrderListContainer, orderList, searchMiniOrderInput, loadMoreBtn;
        
        // --- V1 UI Elements (Left Panel) ---
        let cameraBtn, uploadBtn, fileInput, placeholder, imagePreview, cameraFeed;
        let previewCanvas, rotateBtn, lockBtn, cancelBtn, cancelAllBtn;
        let scrollerContainer, scroller;
        let inlineCropperWrapper, imageViewArea, cropperImage, cropConfirmBtn, cropCancelBtn;
        let cropRotateBtn, selectionCanvas, uploadTypeStrip, statusBar; 
        let enhanceBtn, enhancementControls, autoEnhanceBtn, greyscaleBtn, bwBtn, sharpenBtn, resetEnhanceBtn;
        let brightnessSlider, contrastSlider;
        let tableBody, deleteLastBtn, clearAllBtn, submitBtn; 
        let dynamicInputArea; // <-- NEW Dynamic Input Area UI
        let existingUploadsContainer, existingTableBody; // *** NEW: Existing Uploads UI ***
        let gscriptUrlInput; // *** NEW: GScript URL Input ***


        // --- === IMAGE FUNCTIONS (MOVED TO TOP) === ---
        
        /**
         * Compresses an image data URL to a target size.
         * @param {string} dataUrl - The original image data URL.
         * @param {number} targetSizeKB - The target size in kilobytes.
         * @param {number} maxDimension - The maximum width or height.
         * @returns {Promise<string>} - The compressed image data URL (jpeg).
         */
        async function compressImage(dataUrl, targetSizeKB = 100, maxDimension = 1024) {
            const targetSizeBytes = targetSizeKB * 1024;
            const img = await new Promise(resolve => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.src = dataUrl;
            });

            let { width, height } = img;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Resize based on maxDimension
            if (width > maxDimension || height > maxDimension) {
                if (width > height) {
                    height = Math.round(height * (maxDimension / width));
                    width = maxDimension;
                } else {
                    width = Math.round(width * (maxDimension / height));
                    height = maxDimension;
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);

            let quality = 0.9; // Start with 90% JPEG quality
            let compressedDataUrl;
            let sizeInBytes;

            do {
                compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                sizeInBytes = atob(compressedDataUrl.split(',')[1]).length;
                
                if (sizeInBytes > targetSizeBytes && quality > 0.1) {
                    quality -= 0.1; // Reduce quality by 10%
                }
                
            } while (sizeInBytes > targetSizeBytes && quality > 0.1);
            
            console.log(`Image compressed to ${(sizeInBytes / 1024).toFixed(2)} KB.`);
            return compressedDataUrl;
        }

        /**
         * Applies rotation to an image source.
         * @param {string} src - The image data URL.
         * @param {number} rotation - The rotation angle (0, 90, 180, 270).
         * @returns {Promise<string>} - The rotated image data URL (png).
         */
        function getRotatedImage(src, rotation) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const angle = rotation * Math.PI / 180;

                    if (rotation % 180 !== 0) { // 90 or 270
                        canvas.width = img.height;
                        canvas.height = img.width;
                    } else { // 0 or 180
                        canvas.width = img.width;
                        canvas.height = img.height;
                    }
                    
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(angle);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    
                    resolve(canvas.toDataURL('image/png')); // Return PNG to avoid quality loss before compression
                };
                img.src = src;
            });
        }
        
        // --- === END OF IMAGE FUNCTIONS === ---


        // NEW: Store KYC Options from V1
        const kycOptionsHTML = `
            <optgroup label="Individual">
                <option value="Aadhaar Card">Aadhaar Card</option>
                <option value="PAN Card">PAN Card</option>
                <option value="Indian Passport">Indian Passport</option>
                <option value="Voter ID Card">Voter ID Card</option>
                <option value="Driving License">Driving License</option>
                <option value="NREGA Job Card">NREGA Job Card</option>
            </optgroup>
            <optgroup label="Business">
                <option value="Partnership Deed">Partnership Deed</option>
                <option value="Certificate of Incorporation">Certificate of Incorporation</option>
                <option value="GST Registration">GST Registration</option>
                <option value="MoA & AoA">MoA & AoA</option>
                <option value="Board Resolution">Board Resolution</option>
            </optgroup>
        `;
        
        // --- V1 Status Update Logic ---
        function updateStatus(message, isError = false) {
            if (statusBar) {
                statusBar.textContent = message;
                statusBar.classList.toggle('error', isError);
            }
        }

        // --- V1 UI Control Functions ---
        function setInterfaceState(state) {
            cameraBtn.style.display = 'inline-block';
            uploadBtn.style.display = 'inline-block';
            uploadTypeStrip.style.display = 'flex';
            rotateBtn.style.display = 'none';
            lockBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
            cancelAllBtn.style.display = 'none';
            imageViewArea.classList.remove('selectable');
            cameraFeed.classList.remove('active-capture');

            // Hide buttons that are not relevant in the new UI
            lockBtn.style.display = 'none';
            cancelAllBtn.style.display = 'none';

            if (state === 'streaming') {
                cameraBtn.textContent = 'Capture';
                uploadBtn.style.display = 'none';
                cancelBtn.style.display = 'inline-block';
                previewCanvas.style.display = 'none';
                imagePreview.style.display = 'none';
                cameraFeed.style.display = 'block';
                cameraFeed.classList.add('active-capture');
                uploadTypeStrip.style.display = 'none';
            } else if (state === 'preview') {
                cameraBtn.style.display = 'none';
                uploadBtn.style.display = 'none';
                rotateBtn.style.display = 'inline-block';
                lockBtn.style.display = 'inline-block'; // Re-show lock btn
                imageViewArea.classList.add('selectable');
                uploadTypeStrip.style.display = 'none';
                
                if (imageQueue.length > 1) { // Show scroller if more than 1 image
                     scrollerContainer.style.display = 'block';
                }

                if (imageQueue.length > 0) {
                    cancelBtn.style.display = 'inline-block';
                    cancelAllBtn.style.display = 'inline-block'; // Re-show cancel all
                } else {
                    cancelBtn.style.display = 'inline-block';
                }
            } else { // idle state
                cameraBtn.textContent = 'Camera';
                lockBtn.style.display = 'none';
                cancelAllBtn.style.display = 'none';
            }
        }
        
        // --- NEW: Helper function from V1 ---
        async function dataURLtoFile(dataUrl, fileName) {
            const res = await fetch(dataUrl); 
            const blob = await res.blob();
            return new File([blob], fileName, { type: 'image/jpeg' });
        }
        
        // --- NEW: Camera Logic from V1 ---
        function stopCamera() { 
            if (stream) { 
                stream.getTracks().forEach(track => track.stop()); 
                stream = null; 
            }
            if (cameraFeed) {
                cameraFeed.removeEventListener('click', handleVideoStreamClick);
                cameraFeed.style.display = 'none';
            }
        }
        
        async function handleVideoStreamClick() {
            if (!stream) return;
            if (imageQueue.length >= MAX_FILES) {
                updateStatus(`Maximum of ${MAX_FILES} images reached.`, true);
                return;
            }
            const canvas = document.createElement('canvas');
            canvas.width = cameraFeed.videoWidth;
            canvas.height = cameraFeed.videoHeight;
            canvas.getContext('2d').drawImage(cameraFeed, 0, 0);
            const dataUrl = canvas.toDataURL('image/png');
            const newFile = await dataURLtoFile(dataUrl, `capture-${Date.now()}.png`);
            
            imageQueue.push(newFile);
            scrollerContainer.style.display = 'block';
            renderScroller();
            updateStatus(`${imageQueue.length} image(s) captured.`);
            
            if (cancelBtn.textContent !== 'Done') {
                cancelBtn.textContent = 'Done';
                cancelBtn.style.backgroundColor = '#28a745';
                cancelBtn.style.borderColor = '#28a745';
                cancelBtn.style.color = 'white';
            }
        }
        
        // --- NEW: PDF Processing Logic from V1 ---
        async function handlePdfFile(file) {
            const fileReader = new FileReader();
            return new Promise((resolve, reject) => {
                fileReader.onload = async (e) => {
                    try {
                        const typedarray = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;
                        const imageFiles = [];
                        const scale = 2.0; // Render at 2x scale
                        
                        for (let i = 1; i <= pdf.numPages; i++) {
                            if (imageFiles.length >= MAX_FILES) {
                                updateStatus(`Max ${MAX_FILES} files reached. Stopping PDF processing.`, true);
                                break;
                            }
                            updateStatus(`Processing PDF page ${i} of ${pdf.numPages}...`);
                            const page = await pdf.getPage(i);
                            const viewport = page.getViewport({ scale });
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            const renderContext = { canvasContext: context, viewport: viewport };
                            await page.render(renderContext).promise;
                            
                            const dataUrl = canvas.toDataURL('image/jpeg', 0.9); // 90% quality JPEG
                            const pageFile = await dataURLtoFile(dataUrl, `${file.name}-page-${i}.jpg`);
                            imageFiles.push(pageFile);
                        }
                        resolve(imageFiles);
                    } catch (error) { 
                        console.error("PDF processing error:", error);
                        reject(error); 
                    }
                };
                fileReader.onerror = reject;
                fileReader.readAsArrayBuffer(file);
            });
        }
        
        // --- NEW: Scroller Logic from V1 ---
        function renderScroller() {
            scroller.innerHTML = '';
            imageQueue.forEach((file, index) => {
                const thumb = document.createElement('img');
                try { 
                    thumb.src = URL.createObjectURL(file); 
                    thumb.onload = () => URL.revokeObjectURL(thumb.src); // Revoke to save memory
                } catch(e) { 
                    console.error("Could not create object URL for", file); 
                }
                thumb.className = 'scroller-img'; 
                thumb.dataset.index = index;
                thumb.onclick = () => displayImage(index);
                scroller.appendChild(thumb);
            });
            updateActiveThumbnail();
        }

        function updateActiveThumbnail() {
            document.querySelectorAll('.scroller-img').forEach((img, index) => {
                img.classList.toggle('active', index === currentImageIndex);
            });
        }
        
        function displayImage(index) {
            if (isProcessingImage) return; // Don't switch image while processing
            if (index < 0 || index >= imageQueue.length) { 
                resetUploader(); 
                return; 
            }
            currentImageIndex = index;
            const file = imageQueue[index];
            const reader = new FileReader();
            reader.onload = (e) => initCropper(e.target.result, file.name); // Always go to cropper
            reader.readAsDataURL(file);
        }

        // --- NEW: Cropper Logic from V1 ---
        function initCropper(imageSrc, originalFileName) {
            originalCropperSrc = imageSrc; // Save original for enhancement reset
            currentEnhancements = { brightness: 0, contrast: 0, sharpen: false, greyscale: false, bw: false };
            if (brightnessSlider) brightnessSlider.value = 0;
            if (contrastSlider) contrastSlider.value = 0;
            if (sharpenBtn) sharpenBtn.style.backgroundColor = '';
            if (greyscaleBtn) greyscaleBtn.style.backgroundColor = '';
            if (bwBtn) bwBtn.style.backgroundColor = '';
            if (enhancementControls) enhancementControls.style.display = 'none';

            inlineCropperWrapper.style.display = 'block'; // Show cropper
            imageViewArea.style.display = 'none';      // Hide preview area
            scrollerContainer.style.display = 'none';  // Hide scroller
            placeholder.style.display = 'none';
            
            cropperImage.src = imageSrc;
            if (cropper) cropper.destroy();
            
            cropper = new Cropper(cropperImage, {
                viewMode: 1,
                background: false,
                autoCrop: true,
                autoCropArea: 0.95, // Start with 95% crop area
                zoomable: true,
                movable: true,
                scalable: true,
            });
            
            // This handler is defined inside initCropper to capture the correct file name
            const confirmCropHandler = async () => {
                // *** BUG FIX: Check if cropper still exists AND check lock ***
                if (!cropper || isProcessingImage) {
                    console.warn("Cropper instance destroyed or busy. Cancelling crop.");
                    return;
                }
                isProcessingImage = true; // Set lock
                updateStatus("Cropping...");
                
                const croppedCanvas = cropper.getCroppedCanvas({
                    minWidth: 256, minHeight: 256, maxWidth: 4096, maxHeight: 4096,
                    fillColor: '#fff', imageSmoothingEnabled: true, imageSmoothingQuality: 'high',
                });
                if (!croppedCanvas) { 
                    updateStatus("Crop failed.", true);
                    isProcessingImage = false; // Release lock
                    return; 
                }
                
                let croppedDataUrl = croppedCanvas.toDataURL('image/png'); // Get high-quality PNG
                
                inlineCropperWrapper.style.display = 'none'; // Hide cropper
                imageViewArea.style.display = 'flex';      // Show preview
                
                // *** BUG FIX (THE REAL ONE): Use requestAnimationFrame to prevent draw race condition ***
                imagePreview.onload = () => {
                    // Give the browser one frame to "settle" the image buffer
                    // before we try to draw it to the canvas.
                    requestAnimationFrame(() => {
                        if (previewCanvas.style.display === 'block') { // Check if we weren't cancelled
                            drawPreview();
                            scanBarcodeFromPreview(); 
                        }
                    });
                    imagePreview.onload = null;
                };
                
                imagePreview.src = croppedDataUrl; 
                // *** BUG FIX (THE REAL ONE): DO NOT make the <img> visible. It's just a data source.
                // imagePreview.style.display = 'block'; // <-- THIS WAS THE BUG
                
                placeholder.style.display = 'none';
                cameraFeed.style.display = 'none';
                previewCanvas.style.display = 'block'; // The canvas is the only thing we see
                currentRotation = 0;
                
                // Update the file in the queue with the cropped version
                if (currentImageIndex !== -1) {
                    const newFile = await dataURLtoFile(croppedDataUrl, originalFileName.replace(/\.\w+$/, '.png'));
                    imageQueue[currentImageIndex] = newFile;
                    renderScroller(); // Re-render scroller with new thumbnail
                }
                
                setInterfaceState('preview');
                updateActiveThumbnail();
                
                if(cropper) cropper.destroy();
                cropper = null;
                isProcessingImage = false; // Release lock
            };
            
            cropConfirmBtn.onclick = confirmCropHandler;
        }
        
        // --- NEW: Preview Area Logic from V1 ---
        function drawPreview() {
            if (!imagePreview.src || !imageViewArea || !previewCtx) return;
            const dpr = window.devicePixelRatio || 1;
            const containerW = imageViewArea.clientWidth;
            const containerH = imageViewArea.clientHeight;
            if (!containerW || !containerH) return;
            
            previewCanvas.width = containerW * dpr;
            previewCanvas.height = containerH * dpr;
            previewCanvas.style.width = `${containerW}px`;
            previewCanvas.style.height = `${containerH}px`;
            
            previewCtx.setTransform(dpr, 0, 0, dpr, 0, 0); // Reset and scale
            
            const naturalW = imagePreview.naturalWidth;
            const naturalH = imagePreview.naturalHeight;
            const imgAspect = naturalW / naturalH;
            const contAspect = containerW / containerH;
            let renderedW, renderedH;

            if (imgAspect > contAspect) {
                renderedW = containerW; renderedH = containerW / imgAspect;
            } else {
                renderedH = containerH; renderedW = containerH * imgAspect;
            }
            
            previewCtx.clearRect(0, 0, containerW, containerH);
            previewCtx.save();
            previewCtx.translate(containerW / 2, containerH / 2);
            previewCtx.rotate(currentRotation * Math.PI / 180);
            previewCtx.drawImage(imagePreview, -renderedW / 2, -renderedH / 2, renderedW, renderedH);
            previewCtx.restore();
        }
        
        // --- NEW: Barcode/OCR Logic from V1 ---
        async function scanBarcodeFromPreview() {
            if (!barcodeDetector) {
                updateStatus("Barcode detection not supported. Select area for OCR.", true);
                return;
            }
            if (!imagePreview.src || !imagePreview.src.startsWith('data:')) return;

            try {
                updateStatus("Attempting barcode scan...");
                const barcodes = await barcodeDetector.detect(imagePreview);
                if (barcodes.length > 0) {
                    const barcodeValue = barcodes[0].rawValue.trim(); // Trim the value
                    console.log("Scanned barcode:", barcodeValue);
                    
                    // --- *** NEW LOGIC: Check for selected row first *** ---
                    if (selectedPickupRow) {
                        const input = selectedPickupRow.querySelector('input[type="text"]');
                        if (input) {
                            input.value = barcodeValue;
                            updateStatus(`Filled selected row with: ${barcodeValue}`);
                            return; // Stop here
                        }
                    }

                    // --- *** Fallback: Find matching order *** ---
                    const matchedOrder = allOrders.find(order => 
                        String(order.AWB_NUMBER) === String(barcodeValue) || 
                        String(order.REFERANCE) === String(barcodeValue)
                    );

                    if (matchedOrder) {
                        // Found it!
                        selectedOrder = matchedOrder;
                        updateStatus(`Barcode matched: ${barcodeValue}. Loading tasks...`);
                        filterAndRenderOrders(); // Update right panel list
                        renderDynamicInputs();  // Update left panel pickup table
                        
                        // Scroll the order list to the selected item
                        const selectedLi = orderList.querySelector(`li[data-order-ref="${selectedOrder.REFERANCE}"]`);
                        if (selectedLi) {
                            selectedLi.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    } else {
                        // No match found
                        updateStatus(`Barcode detected: ${barcodeValue} (No matching order found).`);
                        searchMiniOrderInput.value = barcodeValue; // Put in filter
                        filterAndRenderOrders();
                    }
                    
                } else {
                    updateStatus("No barcode found. Please select an area for OCR.");
                }
            } catch (err) {
                console.error("Barcode scan failed:", err);
                updateStatus("Barcode scan failed. Select area for OCR.", true);
            }
        }
        
        function onSelectionStart(e) {
            if (previewCanvas.style.display !== 'block' || isSelecting || isProcessingOCR) return;
            e.preventDefault();
            
            const rect = imageViewArea.getBoundingClientRect();
            selectionCanvas.width = rect.width;
            selectionCanvas.height = rect.height;
            selectionCanvas.style.display = 'block';

            isSelecting = true;
            const point = e.touches ? e.touches[0] : e;
            selectionRect.startX = point.clientX - rect.left;
            selectionRect.startY = point.clientY - rect.top;

            window.addEventListener('mousemove', onSelectionMove, { passive: false });
            window.addEventListener('touchmove', onSelectionMove, { passive: false });
            window.addEventListener('mouseup', onSelectionUp, { once: true });
            window.addEventListener('touchend', onSelectionUp, { once: true });
        }

        function onSelectionMove(e) {
            if (!isSelecting) return;
            e.preventDefault();
            const rect = imageViewArea.getBoundingClientRect();
            const point = e.touches ? e.touches[0] : e;
            const currentX = point.clientX - rect.left;
            const currentY = point.clientY - rect.top;
            const width = currentX - selectionRect.startX;
            const height = currentY - selectionRect.startY;

            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            selectionCtx.strokeStyle = 'red';
            selectionCtx.lineWidth = 2;
            selectionCtx.strokeRect(selectionRect.startX, selectionRect.startY, width, height);
        }
        
        async function onSelectionUp(e) {
            if (!isSelecting) return;
            isSelecting = false;
            window.removeEventListener('mousemove', onSelectionMove);
            window.removeEventListener('touchmove', onSelectionMove);
            
            selectionCanvas.style.display = 'none';
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            
            const rect = imageViewArea.getBoundingClientRect();
            const point = e.changedTouches ? e.changedTouches[0] : e;
            const selectionEndX = point.clientX - rect.left;
            const selectionEndY = point.clientY - rect.top;
            const selX1 = Math.min(selectionRect.startX, selectionEndX);
            const selY1 = Math.min(selectionRect.startY, selectionEndY);
            const selX2 = Math.max(selectionRect.startX, selectionEndX);
            const selY2 = Math.max(selectionRect.startY, selectionEndY);
            const selW = selX2 - selX1;
            const selH = selY2 - selY1;

            if (selW < 10 || selH < 10) return; // Selection too small
            const naturalW = imagePreview.naturalWidth, naturalH = imagePreview.naturalHeight;
            const containerW = imageViewArea.clientWidth, containerH = imageViewArea.clientHeight;
            if (!naturalW || !naturalH || !containerW || !containerH) {
                updateStatus("OCR failed: Image dimensions are zero.", true); return;
            }
            const imgAspect = naturalW / naturalH, contAspect = containerW / containerH;
            let renderedW, renderedH;
            if (imgAspect > contAspect) {
                renderedW = containerW; renderedH = containerW / imgAspect;
            } else {
                renderedH = containerH; renderedW = containerH * imgAspect;
            }
            const offsetX = (containerW - renderedW) / 2, offsetY = (containerH - renderedH) / 2;
            const scaleFactor = naturalW / renderedW;
            const centerX = containerW / 2, centerY = containerH / 2;
            const angle = (-currentRotation * Math.PI / 180), cos = Math.cos(angle), sin = Math.sin(angle);

            const unrotatePoint = (x, y) => {
                const tx = x - centerX, ty = y - centerY;
                const rx = (tx * cos) - (ty * sin), ry = (tx * sin) + (ty * cos);
                return { x: rx + centerX, y: ry + centerY };
            };
            
            const p1 = unrotatePoint(selX1, selY1), p2 = unrotatePoint(selX2, selY1);
            const p3 = unrotatePoint(selX1, selY2), p4 = unrotatePoint(selX2, selY2);
            const unrotatedSelX = Math.min(p1.x, p2.x, p3.x, p4.x);
            const unrotatedSelY = Math.min(p1.y, p2.y, p3.y, p4.y);
            const unrotatedSelW = Math.max(p1.x, p2.x, p3.x, p4.x) - unrotatedSelX;
            const unrotatedSelH = Math.max(p1.y, p2.y, p3.y, p4.y) - unrotatedSelY;
            const sourceX = (unrotatedSelX - offsetX) * scaleFactor;
            const sourceY = (unrotatedSelY - offsetY) * scaleFactor;
            const sourceWidth = unrotatedSelW * scaleFactor;
            const sourceHeight = unrotatedSelH * scaleFactor;

            if (sourceX < 0 || sourceY < 0 || (sourceX + sourceWidth) > naturalW || (sourceY + sourceHeight) > naturalH) {
                updateStatus("Selection was outside the image area.", true); return;
            }

            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = sourceWidth; cropCanvas.height = sourceHeight;
            cropCanvas.getContext('2d').drawImage(imagePreview, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);

            isProcessingOCR = true;
            updateStatus("Running OCR on selected area...");
            try {
                const { data: { text } } = await Tesseract.recognize(cropCanvas, 'eng');
                const ocrText = text.trim().replace(/\s+/g, ''); // Clean OCR text
                
                if (ocrText) {
                    
                    // --- *** NEW LOGIC: Check for selected row first *** ---
                    if (selectedPickupRow) {
                        const input = selectedPickupRow.querySelector('input[type="text"]');
                        if (input) {
                            input.value = ocrText;
                            updateStatus(`Filled selected row with: ${ocrText}`);
                            isProcessingOCR = false;
                            return; // Stop here
                        }
                    }
                    
                    // --- *** Fallback: Find matching order *** ---
                    const matchedOrder = allOrders.find(order => 
                        String(order.AWB_NUMBER) === String(ocrText) || 
                        String(order.REFERANCE) === String(ocrText)
                    );

                    if (matchedOrder) {
                        // Found it!
                        selectedOrder = matchedOrder;
                        updateStatus(`OCR matched: ${ocrText}. Loading tasks...`);
                        filterAndRenderOrders();
                        renderDynamicInputs();
                        const selectedLi = orderList.querySelector(`li[data-order-ref="${selectedOrder.REFERANCE}"]`);
                        if (selectedLi) {
                            selectedLi.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    } else {
                        // No match found - put in filter box
                        updateStatus(`OCR: ${ocrText} (No exact match. Filtering list...).`);
                        searchMiniOrderInput.value = ocrText;
                        filterAndRenderOrders(); // Trigger the filter
                    }
                    // --- *** END NEW LOGIC *** ---
                    
                } else {
                    updateStatus("OCR could not find any text in the selected area.");
                }
            } catch (err) {
                updateStatus("OCR failed on selection.", true);
            } finally {
                setTimeout(() => { isProcessingOCR = false; }, 300);
            }
        }
        
        // --- *** CAMANJS BUG FIX: Re-implemented V1 logic *** ---
        let applyEnhancements = () => {
            if (isProcessingImage || !cropper || !originalCropperSrc) return;
            isProcessingImage = true;
            updateStatus("Applying enhancements...");

            const tempCanvas = document.createElement('canvas');
            const tempImg = new Image();
            tempImg.crossOrigin = "Anonymous";
            tempImg.onload = () => {
                tempCanvas.width = tempImg.width;
                tempCanvas.height = tempImg.height;
                tempCanvas.getContext('2d').drawImage(tempImg, 0, 0);
                
                // This is the CamanJS constructor, which re-initializes.
                Caman(tempCanvas, function () {
                    this.revert(false); // Do not revert to the *very* original, just the last state
                    
                    // Apply filters based on current state
                    if (currentEnhancements.bw) { this.greyscale().contrast(70).brightness(5); }
                    else if (currentEnhancements.greyscale) { this.greyscale(); }
                    if (currentEnhancements.sharpen) { this.sharpen(10); }
                    this.brightness(parseInt(currentEnhancements.brightness, 10));
                    this.contrast(parseInt(currentEnhancements.contrast, 10));
                    
                    this.render(() => {
                        const newDataUrl = this.toBase64();
                        if (cropper) {
                            cropper.replace(newDataUrl);
                        }
                        updateStatus('Enhancements applied.');
                        isProcessingImage = false; // Release lock
                    });
                });
            };
            tempImg.onerror = () => {
                updateStatus("Failed to load image for enhancement.", true);
                isProcessingImage = false; // Release lock
            };
            // CRITICAL: Always apply enhancements to the *original* source
            tempImg.src = originalCropperSrc; 
        }
        
        function resetEnhancements() {
            if (isProcessingImage || !cropper) return;
            isProcessingImage = true;
            updateStatus("Resetting enhancements...");
            currentEnhancements = { brightness: 0, contrast: 0, sharpen: false, greyscale: false, bw: false };
            brightnessSlider.value = 0;
            contrastSlider.value = 0;
            sharpenBtn.style.backgroundColor = '';
            greyscaleBtn.style.backgroundColor = '';
            bwBtn.style.backgroundColor = '';
            cropper.replace(originalCropperSrc); // Revert to original
            updateStatus("Enhancements reset.");
            isProcessingImage = false;
        }
        // --- *** END CAMANJS BUG FIX *** ---

        function resetUploader() {
            stopCamera(); // <-- Call stopCamera
            placeholder.textContent = 'Select Camera or Upload to begin';
            placeholder.style.display = 'block';
            previewCanvas.style.display = 'none';
            cameraFeed.style.display = 'none'; 
            imagePreview.src = '';
            imagePreview.style.display = 'none'; // <-- HIDE image element
            fileInput.value = ''; 
            currentRotation = 0;
            isImageLocked = false; 
            lockBtn.textContent = 'Lock';
            lockBtn.style.backgroundColor = '';
            imageQueue = []; 
            currentImageIndex = -1;
            scroller.innerHTML = ''; 
            scrollerContainer.style.display = 'none';
            inlineCropperWrapper.style.display = 'none';
            imageViewArea.style.display = 'flex';
            selectionCanvas.style.display = 'none';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.backgroundColor = ''; // Reset "Done" button style
            if(cropper) cropper.destroy(); // Destroy cropper instance
            cropper = null;
            isProcessingImage = false; // *** BUG FIX: Release lock on reset ***
            setInterfaceState('idle');
            updateStatus("Select an order or start capture");
        }

        // --- *** NEW: V3 Data Processing (Adopted from V1) *** ---
        function processAppData(appData) {
            if (!appData || !appData.data) {
                console.error("Invalid appData received.");
                updateStatus("Failed to process app data.", true);
                return;
            }
            
            const data = appData.data;
            
            allOrders = Array.isArray(data.ORDERS) ? data.ORDERS : [];
            allClientsB2B = Array.isArray(data.B2B) ? data.B2B : [];
            allClientsB2B2C = Array.isArray(data.B2B2C) ? data.B2B2C : [];
            allProducts = Array.isArray(data.PRODUCT) ? data.PRODUCT : [];
            allUploads = Array.isArray(data.UPLOADS) ? data.UPLOADS : []; 
            
            allOrders.sort((a, b) => {
                try {
                    const dateA = new Date(a.ORDER_DATE);
                    const dateB = new Date(b.ORDER_DATE);
                    if (isNaN(dateA.getTime())) return 1;
                    if (isNaN(dateB.getTime())) return -1;
                    return dateB - dateA; 
                } catch (e) {
                    return 0;
                }
            });
            
            filterAndRenderOrders(); // Render the order list
            
            // Check if an order was already selected and re-render tables
            if (selectedOrder) {
                // Find the selectedOrder object in the *new* allOrders list
                const updatedSelectedOrder = allOrders.find(o => String(o.REFERANCE) === String(selectedOrder.REFERANCE));
                if (updatedSelectedOrder) {
                    selectedOrder = updatedSelectedOrder; // Update the object
                    renderDynamicInputs(); // Re-render pickup and existing tables
                } else {
                    // The old selected order is gone, reset.
                    selectedOrder = null;
                    renderDynamicInputs();
                }
            }
            
            updateStatus("App data loaded. Ready."); 
        }

        // --- *** NEW: V3 Data Listeners (Adopted from V1) *** ---
        function initializeV1DataListeners() {
            // Listen for data loaded/refreshed from the main site (e.g., layout.js)
            window.addEventListener('appDataLoaded', (e) => {
                console.log("Event 'appDataLoaded' received.");
                processAppData(e.detail);
            });
            
            window.addEventListener('appDataRefreshed', (e) => {
                console.log("Event 'appDataRefreshed' received.");
                processAppData(e.detail);
            });
        }


        // --- List Filtering and Rendering (Right Panel) ---

        function formatDate(dateString) {
            if (!dateString) return 'N/A';
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return 'Invalid Date';
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            } catch (e) {
                return 'Invalid Date';
            }
        }
        
        function renderMiniOrderList(ordersToRender) {
            if (!orderList) return;
            orderList.innerHTML = '';
            displayedOrders = ordersToRender;

            if (!ordersToRender || ordersToRender.length === 0) {
                orderList.innerHTML = '<li class="status-message">No matching orders found.</li>';
                loadMoreBtn.style.display = 'none';
                return;
            }

            ordersToRender.forEach((order) => {
                const ref = order.REFERANCE;
                if (!ref) return;
                const displayAwb = order.AWB_NUMBER || ref;
                const consignorClient = allClientsB2B2C.find(c => c.UID === order.CONSIGNOR);
                const consignorName = consignorClient ? (consignorClient.NAME || 'Unknown') : 'Unknown';
                const consigneeClient = allClientsB2B2C.find(c => c.UID === order.CONSIGNEE);
                const consigneeName = consigneeClient ? (consigneeClient.NAME || 'Unknown') : 'Unknown';
                const destination = order.DEST_CITY || 'N/A';
                const orderDate = formatDate(order.ORDER_DATE);
                const value = order.VALUE || 0;
                const pieces = order.PIECS || 0;
                const li = document.createElement('li');
                li.innerHTML = `<strong>${displayAwb}</strong>
                                <div class="client-info">${consignorName} -> ${consigneeName}</div>
                                <div class="details-info">Date: ${orderDate} | Value: ${value} | Pcs: ${pieces}</div>
                                <div class="dest-info">Dest: ${destination}</div>`;
                li.dataset.orderRef = ref;
                // NEW: Check if this order is the selected one
                if (selectedOrder && selectedOrder.REFERANCE === ref) {
                    li.classList.add('selected');
                }
                orderList.appendChild(li);
            });

            const searchTerm = searchMiniOrderInput ? searchMiniOrderInput.value.toLowerCase() : "";
            const totalFilteredCount = filterOrdersBySearchTerm(searchTerm).length;
            
            if (ordersToRender.length < totalFilteredCount) {
                loadMoreBtn.style.display = 'block';
                loadMoreBtn.disabled = false;
                loadMoreBtn.textContent = `Load More (${ordersToRender.length} / ${totalFilteredCount})`;
            } else {
                loadMoreBtn.style.display = 'none';
            }
        }
        
        function filterOrdersBySearchTerm(searchTerm) {
            if (!Array.isArray(allOrders)) return [];
            if (!searchTerm) return allOrders;
            return allOrders.filter(order => {
                const consignorClient = allClientsB2B2C.find(c => c.UID === order.CONSIGNOR);
                const consignorName = consignorClient ? (consignorClient.NAME || '') : '';
                const consigneeClient = allClientsB2B2C.find(c => c.UID === order.CONSIGNEE);
                const consigneeName = consigneeClient ? (consigneeClient.NAME || '') : '';
                const destination = order.DEST_CITY || '';
                const orderDateStr = formatDate(order.ORDER_DATE).toLowerCase();
                return (order.REFERANCE ? String(order.REFERANCE).toLowerCase().includes(searchTerm) : false) ||
                       (order.AWB_NUMBER ? String(order.AWB_NUMBER).toLowerCase().includes(searchTerm) : false) ||
                       (consignorName ? consignorName.toLowerCase().includes(searchTerm) : false) ||
                       (consigneeName ? consigneeName.toLowerCase().includes(searchTerm) : false) ||
                       (destination ? destination.toLowerCase().includes(searchTerm) : false) ||
                       (orderDateStr ? orderDateStr.includes(searchTerm) : false);
            });
        }
        
        function filterOrdersByDate(orders) {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - displayDays);
            cutoffDate.setHours(0, 0, 0, 0);
            if (!Array.isArray(orders)) return [];
            return orders.filter(order => {
                const orderDate = order.ORDER_DATE ? new Date(order.ORDER_DATE) : null;
                return orderDate && orderDate >= cutoffDate;
            });
        }

        function filterAndRenderOrders() {
            const searchTerm = searchMiniOrderInput ? searchMiniOrderInput.value.toLowerCase() : "";
            let searchFilteredOrders = filterOrdersBySearchTerm(searchTerm);
            if (!Array.isArray(searchFilteredOrders)) searchFilteredOrders = [];
            const dateFilteredOrders = filterOrdersByDate(searchFilteredOrders);
            renderMiniOrderList(dateFilteredOrders);
        }

        // --- === NEW: Function to render existing uploads FOR A SPECIFIC ORDER === ---
        function renderExistingUploadsForOrder(order) {
            if (!existingTableBody || !order) {
                existingUploadsContainer.style.display = 'none';
                return;
            }
            
            existingTableBody.innerHTML = ''; // Clear previous
            
            // Find all uploads matching the selected order's REF or AWB
            const matchingUploads = allUploads.filter(upload => 
                (upload.REFERANCE && String(upload.REFERANCE) === String(order.REFERANCE)) ||
                (upload.AWB_NUMBER && String(upload.AWB_NUMBER) === String(order.AWB_NUMBER))
            );

            if (matchingUploads.length === 0) {
                existingUploadsContainer.style.display = 'none';
                return;
            }

            matchingUploads.forEach(upload => {
                // Get consignor/consignee names from the *selected order* object
                const consignorName = selectedOrder.CONSIGNOR_NAME || 'N/A';
                const consigneeName = selectedOrder.CONSIGNEE_NAME || 'N/A';

                const newRow = existingTableBody.insertRow();
                
                // Add data attributes for filtering
                newRow.dataset.keyRef = upload.REFERANCE || upload.AWB_NUMBER;
                newRow.dataset.keyType = upload.UPLOAD_TYPE;
                newRow.dataset.branch = upload.BRANCH || '';
                newRow.dataset.code = upload.CODE || '';

                // Build row data based on upload type
                const rowData = {
                    type: upload.UPLOAD_TYPE || 'N/A',
                    status: upload.STATUS_REMARK || '', // *** FIX: No 'N/A' ***
                    refAwb: (upload.UPLOAD_TYPE === 'MultiBox')
                        ? `Ref: ${upload.REFERANCE || upload.AWB_NUMBER} <br> Child: ${upload.CHILD_AWB}`
                        : `Ref: ${upload.REFERANCE || ''} <br> AWB: ${upload.AWB_NUMBER || ''}`,
                    customerKyc: upload.UPLOAD_TYPE === 'KYC' 
                        ? `Cust: ${consignorName} <br> UID: ${upload.CUSTOMER_UID || ''} <br> KYC: ${upload.KYC_NUMBER} (${upload.KYC_TYPE})`
                        : '', // *** FIX: No 'N/A' ***
                    docInfo: upload.UPLOAD_TYPE === 'Product'
                        ? `Doc: ${upload.DOC_NUMBER || ''} <br> Type: ${upload.DOC_TYPE || ''} <br> Remark: ${upload.STATUS_REMARK || ''}`
                        : '', // *** FIX: No 'N/A' ***
                    image: upload.FILE_URL
                };
                
                // Manually set status for POD/Reciept if remark is empty
                if (upload.UPLOAD_TYPE === 'POD' && !upload.STATUS_REMARK) rowData.status = 'Delivered';
                if (upload.UPLOAD_TYPE === 'Reciept' && !upload.STATUS_REMARK) rowData.status = 'Booked';

                // Create cells
                newRow.insertCell().textContent = `${rowData.type} - ${rowData.status}`;
                newRow.insertCell().innerHTML = rowData.refAwb;
                newRow.insertCell().innerHTML = rowData.customerKyc || 'N/A';
                newRow.insertCell().innerHTML = rowData.docInfo || 'N/A';
                
                // Image Cell
                const imageCell = newRow.insertCell();
                const thumb = document.createElement('img');
                thumb.src = rowData.image; // Use FILE_URL directly as src
                const cellDiv = document.createElement('div');
                cellDiv.className = 'image-cell-content';
                // Make the image a link
                const link = document.createElement('a');
                link.href = rowData.image;
                link.target = '_blank';
                link.appendChild(thumb);
                cellDiv.appendChild(link);
                imageCell.appendChild(cellDiv);
                
                // Hidden Branch/Code Cell
                const hiddenCell = newRow.insertCell();
                hiddenCell.textContent = `Branch: ${upload.BRANCH}, Code: ${upload.CODE}`;
                hiddenCell.style.display = 'none';
            });
            
            existingUploadsContainer.style.display = 'block'; // Show the container
        }
        
        // --- === DYNAMIC INPUT LOGIC (Refactored) === ---
        
        /**
         * *** MODIFIED ***
         * Checks if a POD or Reciept task is already in the main upload table OR existing uploads
         */
        function checkUploadStatus(ref, awb) {
            const status = { pod: false, reciept: false };
            
            // 1. Check NEWLY staged items in the main upload table
            const rows = tableBody.rows;
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const keyRef = row.dataset.keyRef;
                const keyType = row.dataset.keyType;
                const refMatch = String(keyRef) === String(ref) || String(keyRef) === String(awb);
                
                if (refMatch && keyType === 'POD') {
                    status.pod = true;
                }
                if (refMatch && keyType === 'Reciept') {
                    status.reciept = true;
                }
            }
            
            // 2. Check EXISTING uploads
            allUploads.forEach(upload => {
                 const refMatch = (upload.REFERANCE && String(upload.REFERANCE) === String(ref)) ||
                                (upload.AWB_NUMBER && String(upload.AWB_NUMBER) === String(awb));
                 if (refMatch) {
                    if (upload.UPLOAD_TYPE === 'POD') {
                        status.pod = true;
                    }
                    if (upload.UPLOAD_TYPE === 'Reciept') {
                        status.reciept = true;
                    }
                 }
            });
            
            return status;
        }

        /**
         * Creates a single pick button for the table
         */
        function createPickButton(pickData) {
            const button = document.createElement('button');
            button.className = 'v1-btn pick-btn-dynamic';
            button.textContent = 'Pick';
            for (const [key, val] of Object.entries(pickData)) {
                button.dataset[key] = val;
            }
            return button;
        }

        /**
         * Renders the POD row in the pickup table
         */
        function renderPodRow(tableBody, { ref, awb }) {
            // Check is now done in renderDynamicInputs
            const pickData = { 'type': 'POD', 'ref': ref, 'awb': awb };
            const row = tableBody.insertRow();
            row.innerHTML = `
                <td>POD</td>
                <td>${ref} / ${awb}</td>
                <td>Status</td>
                <td><input type="text" class="dynamic-text-input" placeholder="Delivered (default)"></td>
            `;
            row.insertCell().appendChild(createPickButton(pickData));
        }

        /**
         * Renders the Receipt row in the pickup table
         */
        function renderReceiptRow(tableBody, { ref, awb }) {
            // Check is now done in renderDynamicInputs
            const pickData = { 'type': 'Reciept', 'ref': ref, 'awb': awb };
            const row = tableBody.insertRow();
            row.innerHTML = `
                <td>Reciept</td>
                <td>${ref} / ${awb}</td>
                <td>Status</td>
                <td><input type="text" class="dynamic-text-input" placeholder="Booked (default)"></td>
            `;
            row.insertCell().appendChild(createPickButton(pickData));
        }

        /**
         * Renders the KYC rows in the pickup table
         */
        function renderKycRows(tableBody, { ref, consignorName, consignorUid, consigneeName, consigneeUid }) {
            // Row 1: Consignor
            let pickData = { 'type': 'KYC', 'ref': ref, 'customerName': consignorName, 'customerUid': consignorUid };
            const kycRow1 = tableBody.insertRow();
            kycRow1.innerHTML = `
                <td>KYC</td>
                <td>${ref}</td>
                <td>${consignorName}</td>
                <td>
                    <div class="kyc-inputs">
                        <input type="text" class="kyc-number-input" placeholder="KYC Number">
                        <select class="kyc-type-select">${kycOptionsHTML}</select>
                    </div>
                </td>
            `;
            kycRow1.insertCell().appendChild(createPickButton(pickData));
            
            // Row 2: Consignee
            pickData = { 'type': 'KYC', 'ref': ref, 'customerName': consigneeName, 'customerUid': consigneeUid };
            const kycRow2 = tableBody.insertRow();
            kycRow2.innerHTML = `
                <td>KYC</td>
                <td>${ref}</td>
                <td>${consigneeName}</td>
                <td>
                    <div class="kyc-inputs">
                        <input type="text" class="kyc-number-input" placeholder="KYC Number">
                        <select class="kyc-type-select">${kycOptionsHTML}</select>
                    </div>
                </td>
            `;
            kycRow2.insertCell().appendChild(createPickButton(pickData));
        }

        /**
         * Renders the Product rows in the pickup table
         */
        function renderProductRows(tableBody, { ref }) {
            const products = allProducts.filter(p => String(p.RERERANCE) === String(ref));
            if (products.length > 0) {
                products.forEach(product => {
                    const docNum = product.DOC_NUMBER || ''; // *** FIX: Use '' not 'N/A' ***
                    const docType = product.TYPE || ''; // *** FIX: Use '' not 'N/A' ***
                    const pickData = { 'type': 'Product', 'ref': ref, 'docNumber': docNum, 'docType': docType };
                    
                    const productRow = tableBody.insertRow();
                    productRow.innerHTML = `
                        <td>Product</td>
                        <td>${ref}</td>
                        <td>Doc: ${docNum || 'N/A'} (${docType || 'N/A'})</td>
                        <td><input type="text" class="dynamic-text-input" placeholder="PAPERS UPLOADED (default)"></td>
                    `;
                    productRow.insertCell().appendChild(createPickButton(pickData));
                });
            } else if (currentUploadType === 'Product') { // Only show "no products" if in filter mode
                tableBody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 15px; color: #888;">No products found for this order.</td></tr>';
            }
        }

        /**
         * Renders the MultiBox row in the pickup table
         */
        function renderMultiBoxRow(tableBody, { ref, awb }) {
            const pickData = { 'type': 'MultiBox', 'ref': ref, 'awb': awb };
            const multiBoxRow = tableBody.insertRow();
            multiBoxRow.innerHTML = `
                <td>MultiBox</td>
                <td>${ref} / ${awb}</td>
                <td>Child AWB</td>
                <td><input type="text" class="dynamic-text-input" placeholder="Enter Child AWB (default: ${awb})"></td>
            `;
            multiBoxRow.insertCell().appendChild(createPickButton(pickData));
        }

        /**
         * Renders the dynamic input rows based on selected order and upload type
         */
        function renderDynamicInputs() {
            if (!dynamicInputArea) return;
            dynamicInputArea.innerHTML = ''; // Clear previous inputs
            selectedPickupRow = null; // Clear row selection
            
            // *** NEW: Also hide/clear existing uploads when re-rendering ***
            if (existingUploadsContainer) existingUploadsContainer.style.display = 'none';
            if (existingTableBody) existingTableBody.innerHTML = '';

            if (!selectedOrder) {
                dynamicInputArea.innerHTML = '<div class="placeholder">Select an order from the list...</div>';
                return;
            }

            // --- 1. Get all order details ---
            const ref = selectedOrder.REFERANCE;
            const awb = selectedOrder.AWB_NUMBER || ''; // *** FIX: Use '' not 'N/A' ***
            const consignorUid = selectedOrder.CONSIGNOR;
            const consigneeUid = selectedOrder.CONSIGNEE;
            
            const consignorClient = allClientsB2B2C.find(c => c.UID === consignorUid);
            const consignorName = consignorClient ? (consignorClient.NAME || `UID: ${consignorUid}`) : `UID: ${consignorUid}`;
            
            const consigneeClient = allClientsB2B2C.find(c => c.UID === consigneeUid);
            const consigneeName = consigneeClient ? (consigneeClient.NAME || `UID: ${consigneeUid}`) : `UID: ${consigneeUid}`;
            
            selectedOrder.CONSIGNOR_NAME = consignorName;
            selectedOrder.CONSIGNEE_NAME = consigneeName;

            const orderDetails = { ref, awb, consignorUid, consignorName, consigneeUid, consigneeName };

            // --- *** NEW RULE CHECK *** ---
            const uploadStatus = checkUploadStatus(ref, awb);

            if (uploadStatus.pod) {
                dynamicInputArea.innerHTML = '<div class="placeholder" style="color: green; font-weight: bold;">POD already uploaded for this order. No further tasks available.</div>';
                renderExistingUploadsForOrder(selectedOrder); // Still show existing uploads
                return; // Stop here
            }
            // --- *** END NEW RULE CHECK *** ---


            // --- 2. Create table structure ---
            const table = document.createElement('table');
            table.className = 'pickup-table';
            
            const tableHead = `
                <thead>
                    <tr>
                        <th>TYPE</th>
                        <th>REFERENCE</th>
                        <th>DETAILS</th>
                        <th>INPUT</th>
                        <th>ACTION</th>
                    </tr>
                </thead>
            `;
            const tableBody = document.createElement('tbody');

            // --- 3. Populate table based on mode ---
            if (currentUploadType === null) {
                // "All" mode - render every type
                renderPodRow(tableBody, orderDetails); // POD check is already done
                if (!uploadStatus.reciept) { // Check for Reciept
                    renderReceiptRow(tableBody, orderDetails);
                }
                renderKycRows(tableBody, orderDetails);
                renderProductRows(tableBody, orderDetails);
                renderMultiBoxRow(tableBody, orderDetails);
            } else {
                // "Filter" mode - render only the selected type
                switch (currentUploadType) {
                    case 'POD':
                        renderPodRow(tableBody, orderDetails); // POD check is already done
                        break;
                    case 'Reciept':
                        if (!uploadStatus.reciept) { // Check for Reciept
                            renderReceiptRow(tableBody, orderDetails);
                        }
                        break;
                    case 'KYC':
                        renderKycRows(tableBody, orderDetails);
                        break;
                    case 'Product':
                        renderProductRows(tableBody, orderDetails);
                        break;
                    case 'MultiBox':
                        renderMultiBoxRow(tableBody, orderDetails);
                        break;
                    default:
                        tableBody.innerHTML = `<tr><td colspan="5" style="text-align: center; padding: 15px; color: #888;">Input logic for "${currentUploadType}" not defined.</td></tr>`;
                }
            }
            
            table.innerHTML = tableHead;
            table.appendChild(tableBody);
            dynamicInputArea.appendChild(table);
            
            // --- 4. *** NEW: Render existing uploads for this order ***
            renderExistingUploadsForOrder(selectedOrder);
        }

        // --- === END: DYNAMIC INPUT LOGIC === ---
        
        // --- *** NEW: PDF Creation Function *** ---
        async function createPdfFromImages(images) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF("p", "mm", "a4");
            const a4Width = 210;
            const a4Height = 297;
            const margin = 10;
            const imgWidth = a4Width - (margin * 2);
            
            for (let i = 0; i < images.length; i++) {
                const imgData = images[i];
                if (i > 0) {
                    doc.addPage();
                }
                
                // Get image dimensions to calculate aspect ratio
                const img = await new Promise(resolve => {
                    const image = new Image();
                    image.onload = () => resolve(image);
                    image.src = imgData;
                });

                const aspectRatio = img.height / img.width;
                const imgHeight = imgWidth * aspectRatio;

                // Check if it fits, if not, scale to fit height
                let finalWidth = imgWidth;
                let finalHeight = imgHeight;
                if (finalHeight > (a4Height - (margin * 2))) {
                    finalHeight = a4Height - (margin * 2);
                    finalWidth = finalHeight / aspectRatio;
                }

                doc.addImage(imgData, 'JPEG', margin, margin, finalWidth, finalHeight);
            }
            
            // Return base64 string
            return doc.output('datauristring');
        }


        // --- App Initialization ---
        function initializeData() {
            // Assign Right Panel UI
            miniOrderListContainer = document.getElementById('miniOrderListContainer');
            orderList = document.getElementById('miniOrderList');
            searchMiniOrderInput = document.getElementById('searchMiniOrder');
            loadMoreBtn = document.getElementById('loadMoreBtn');
            
            // Add Right Panel Listeners
            searchMiniOrderInput.addEventListener('input', filterAndRenderOrders);
            loadMoreBtn.addEventListener('click', () => {
                displayDays += 90; // Load 90 more days
                filterAndRenderOrders();
            });

            // NEW: Add click listener for order selection
            orderList.addEventListener('click', (e) => {
                const li = e.target.closest('li');
                if (!li || !li.dataset.orderRef) return;
                
                const ref = li.dataset.orderRef;
                selectedOrder = allOrders.find(o => String(o.REFERANCE) === ref);
                
                if (selectedOrder) {
                    console.log("Selected Order:", selectedOrder);
                    // Re-render list to show selection
                    filterAndRenderOrders();
                    // Render the dynamic inputs on the left
                    renderDynamicInputs();
                }
            });

            // *** REMOVED: loadData() call ***
        }
        
        // --- Main DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => {
             // 1. Initialize Right Panel (Data Listeners)
             initializeData(); // This still sets up search/click listeners
             
             // *** NEW: Call the V1 data listener setup ***
             initializeV1DataListeners();

             // 2. Assign Left Panel (Uploader UI)
             cameraBtn = document.getElementById('camera-btn');
             uploadBtn = document.getElementById('upload-btn');
             fileInput = document.getElementById('file-input');
             placeholder = document.getElementById('placeholder');
             imagePreview = document.getElementById('image-preview');
             cameraFeed = document.getElementById('camera-feed');
             previewCanvas = document.getElementById('preview-canvas');
             rotateBtn = document.getElementById('rotate-btn');
             lockBtn = document.getElementById('lock-btn');
             cancelBtn = document.getElementById('cancel-btn');
             cancelAllBtn = document.getElementById('cancel-all-btn');
             scrollerContainer = document.getElementById('image-scroller-container');
             scroller = document.getElementById('image-scroller');
             inlineCropperWrapper = document.getElementById('inline-cropper-wrapper');
             imageViewArea = document.getElementById('image-view-area');
             cropperImage = document.getElementById('cropper-image');
             cropConfirmBtn = document.getElementById('crop-confirm-btn');
             cropCancelBtn = document.getElementById('crop-cancel-btn');
             cropRotateBtn = document.getElementById('crop-rotate-btn');
             selectionCanvas = document.getElementById('selection-canvas');
             uploadTypeStrip = document.querySelector('.upload-type-strip');
             statusBar = document.getElementById('status-bar'); 
             enhanceBtn = document.getElementById('enhance-btn');
             enhancementControls = document.getElementById('enhancement-controls');
             autoEnhanceBtn = document.getElementById('auto-enhance-btn');
             greyscaleBtn = document.getElementById('greyscale-btn');
             bwBtn = document.getElementById('bw-btn');
             sharpenBtn = document.getElementById('sharpen-btn');
             resetEnhanceBtn = document.getElementById('reset-enhance-btn');
             brightnessSlider = document.getElementById('brightness-slider');
             contrastSlider = document.getElementById('contrast-slider');
             tableBody = document.getElementById('data-table-body');
             deleteLastBtn = document.getElementById('delete-last-btn');
             clearAllBtn = document.getElementById('clear-all-btn');
             submitBtn = document.getElementById('submit-btn');
             dynamicInputArea = document.getElementById('dynamic-input-area');
             // *** NEW: Assign Existing Uploads UI ***
             existingUploadsContainer = document.getElementById('existing-uploads-container');
             existingTableBody = document.getElementById('existing-data-table-body');
             gscriptUrlInput = document.getElementById('gscript-url'); // *** NEW: Assign GScript URL ***


             // Assign canvas contexts
             selectionCtx = selectionCanvas.getContext('2d');
             previewCtx = previewCanvas.getContext('2d');
             
             // 3. Set initial state of the uploader
             resetUploader();
             
             // 4. *** NEW: V1 logic to check for cached data on load ***
             try {
                const appDataJSON = localStorage.getItem('appData');
                if (appDataJSON) {
                    console.log("Found cached appData on load. Processing...");
                    const appData = JSON.parse(appDataJSON);
                    if (appData.data) {
                        processAppData(appData);
                    } else {
                        console.warn("Cached appData is in an invalid format.");
                        updateStatus("Cached data invalid. Waiting for network...", true);
                    }
                } else {
                    console.log("No cached appData. Waiting for 'appDataLoaded' event.");
                    updateStatus("Waiting for app data from main site...");
                }
             } catch (e) {
                console.error("Failed to parse cached appData on load:", e);
                updateStatus("Error loading cached data. Waiting for network...", true);
             }


             // 5. NEW: Add Left Panel UI Listeners
             uploadTypeStrip.addEventListener('click', (e) => {
                if (e.target.classList.contains('type-btn')) {
                    const selectedType = e.target.dataset.type;
                    
                    // NEW Toggle Logic
                    if (e.target.classList.contains('active')) {
                        // Clicked an active button - deselect it
                        e.target.classList.remove('active');
                        currentUploadType = null;
                    } else {
                        // Clicked an inactive button - select it
                        uploadTypeStrip.querySelector('.active')?.classList.remove('active');
                        e.target.classList.add('active');
                        currentUploadType = selectedType;
                    }
                    
                    console.log("Upload type changed to:", currentUploadType);
                    
                    // Re-render inputs if an order is already selected
                    if (selectedOrder) {
                        renderDynamicInputs();
                    }
                }
             });

             // --- === ALL NEW CLICK HANDLERS (from V1) === ---
             
             // --- Camera/Upload Button Handlers ---
             cameraBtn.addEventListener('click', async () => {
                if (isProcessingImage) return; // *** BUG FIX: Check lock ***
                if (stream) {
                    // This is the "Capture" click
                    const canvas = document.createElement('canvas');
                    canvas.width = cameraFeed.videoWidth;
                    canvas.height = cameraFeed.videoHeight;
                    canvas.getContext('2d').drawImage(cameraFeed, 0, 0);
                    const dataUrl = canvas.toDataURL('image/png');
                    stopCamera();
                    imageQueue = []; // Reset queue for single capture mode
                    currentImageIndex = 0; // Set index to 0
                    imageQueue.push(await dataURLtoFile(dataUrl, `capture-${Date.now()}.png`)); // Add file to queue
                    initCropper(dataUrl, `capture-${Date.now()}.png`);
                    
                } else {
                    // This is the "Camera" click
                    resetUploader(); // Clear previous state
                    placeholder.textContent = 'Starting camera...';
                    placeholder.style.display = 'block';

                    const constraints = { video: { facingMode: { ideal: "environment" } } };
                    try {
                        stream = await navigator.mediaDevices.getUserMedia(constraints);
                    } catch (err) {
                       updateStatus("Could not access camera. Check permissions.", true);
                       console.error(err);
                       resetUploader();
                       return;
                    }
                    
                    cameraFeed.style.display = 'block';
                    placeholder.style.display = 'none';
                    cameraFeed.srcObject = stream;
                    cameraFeed.play(); 
                    setInterfaceState('streaming');
                    cameraFeed.addEventListener('click', handleVideoStreamClick);
                }
            });
            
            uploadBtn.addEventListener('click', () => { 
                if (isProcessingImage) return; // *** BUG FIX: Check lock ***
                fileInput.click(); 
            });
            
            fileInput.addEventListener('change', async (event) => {
                if (isProcessingImage) return; // *** BUG FIX: Check lock ***
                isProcessingImage = true; // Set lock
                
                const files = Array.from(event.target.files);
                if (files.length === 0) {
                    isProcessingImage = false;
                    return;
                }
                
                updateStatus('Processing uploaded files...');
                let processedFiles = [];
                for (const file of files) {
                    if (file.type === 'application/pdf') {
                        try {
                            const pdfImages = await handlePdfFile(file);
                            processedFiles.push(...pdfImages);
                        } catch (error) { 
                            updateStatus(`Failed to process PDF: ${file.name}`, true); 
                        }
                    } else if (file.type.startsWith('image/')) {
                        processedFiles.push(file);
                    }
                }
                
                if (processedFiles.length > MAX_FILES) {
                    updateStatus(`Max ${MAX_FILES} files allowed. Loading first ${MAX_FILES}.`, true);
                    processedFiles = processedFiles.slice(0, MAX_FILES);
                }
                if (processedFiles.length === 0) {
                    updateStatus('No valid images found or processed.', true); 
                    isProcessingImage = false;
                    return;
                }
                
                imageQueue = processedFiles;
                scrollerContainer.style.display = imageQueue.length > 1 ? 'block' : 'none';
                if (imageQueue.length > 1) renderScroller();
                
                isProcessingImage = false; // Release lock *before* displaying image
                displayImage(0); // Display the first image in the cropper
                updateStatus(`${imageQueue.length} image(s) loaded.`);
            });
             
             // --- Cropper Button Handlers ---
             cropRotateBtn.addEventListener('click', () => {
                if (isProcessingImage || !cropper) return; // *** BUG FIX: Check lock ***
                cropper.rotate(90); // Use cropper's built-in rotate method
            });
            
            cropCancelBtn.addEventListener('click', () => {
                if (isProcessingImage) return; // *** BUG FIX: Check lock ***
                
                inlineCropperWrapper.style.display = 'none';
                imageViewArea.style.display = 'flex';
                if(cropper) cropper.destroy();
                cropper = null;
                
                if (imageQueue.length > 0) {
                    // We were in a queue, show the preview screen
                    setInterfaceState('preview');
                    // We need to re-display the *uncropped* image from the file
                    displayImage(currentImageIndex); 
                } else {
                    // We were not in a queue (e.g., single camera shot), reset
                    resetUploader();
                }
            });
             
             // --- Preview Button Handlers ---
             rotateBtn.addEventListener('click', () => {
                if (isProcessingImage) return; // *** BUG FIX: Check lock ***
                if (previewCanvas.style.display === 'block') {
                    currentRotation = (currentRotation + 90) % 360;
                    drawPreview();
                    scanBarcodeFromPreview();
                }
            });

            lockBtn.addEventListener('click', () => {
                if (isProcessingImage) return; // *** BUG FIX: Check lock ***
                isImageLocked = !isImageLocked;
                lockBtn.textContent = isImageLocked ? 'Unlock' : 'Lock';
                lockBtn.style.backgroundColor = isImageLocked ? '#d4edda' : '';
                updateStatus(isImageLocked ? "Image locked. It will not be cleared after picking." : "Image unlocked.");
            });

            cancelBtn.addEventListener('click', () => {
                if (isProcessingImage) return; // *** BUG FIX: Check lock ***
                if (stream) { // "Done" or "Cancel" in streaming mode
                    if (cancelBtn.textContent === 'Done' && imageQueue.length > 0) {
                        stopCamera();
                        displayImage(0); // Go to cropper with first image
                    } else {
                        resetUploader(); // Just cancel
                    }
                    return;
                }

                // "Cancel" in preview mode
                if (isImageLocked) { 
                    resetUploader(); // If locked, cancel all
                    return; 
                }
                
                if (imageQueue.length > 0) {
                     imageQueue.splice(currentImageIndex, 1); // Remove current image
                     renderScroller();
                     // Display next image or reset
                     displayImage(currentImageIndex < imageQueue.length ? currentImageIndex : 0);
                } else {
                    resetUploader();
                }
            });

            cancelAllBtn.addEventListener('click', () => {
                 if (isProcessingImage) return; // *** BUG FIX: Check lock ***
                 resetUploader();
            });
            
            // --- Preview Area Handlers (OCR) ---
            imageViewArea.addEventListener('mousedown', onSelectionStart);
            imageViewArea.addEventListener('touchstart', onSelectionStart, { passive: false });

             // --- Enhancement Button Handlers ---
            enhanceBtn.addEventListener('click', () => { 
                if (isProcessingImage) return; // *** BUG FIX: Check lock ***
                enhancementControls.style.display = enhancementControls.style.display === 'block' ? 'none' : 'block'; 
            });
            
            resetEnhanceBtn.addEventListener('click', resetEnhancements);
            
            const applyEnhanceDebounce = () => { 
                currentEnhancements.brightness = brightnessSlider.value; 
                currentEnhancements.contrast = contrastSlider.value; 
                applyEnhancements(); 
            };
            brightnessSlider.addEventListener('input', applyEnhanceDebounce);
            contrastSlider.addEventListener('input', applyEnhanceDebounce);
            
            sharpenBtn.addEventListener('click', () => { 
                currentEnhancements.sharpen = !currentEnhancements.sharpen; 
                sharpenBtn.style.backgroundColor = currentEnhancements.sharpen ? '#d4edda' : ''; 
                applyEnhancements(); 
            });
            
            greyscaleBtn.addEventListener('click', () => {
                currentEnhancements.greyscale = !currentEnhancements.greyscale;
                if (currentEnhancements.greyscale) { 
                    currentEnhancements.bw = false; 
                    bwBtn.style.backgroundColor = ''; 
                }
                greyscaleBtn.style.backgroundColor = currentEnhancements.greyscale ? '#d4edda' : ''; 
                applyEnhancements();
            });

            bwBtn.addEventListener('click', () => {
                currentEnhancements.bw = !currentEnhancements.bw;
                if (currentEnhancements.bw) { 
                    currentEnhancements.greyscale = false; 
                    greyscaleBtn.style.backgroundColor = ''; 
                }
                bwBtn.style.backgroundColor = currentEnhancements.bw ? '#d4edda' : ''; 
                applyEnhancements();
            });

            autoEnhanceBtn.addEventListener('click', () => {
                currentEnhancements.sharpen = true; 
                currentEnhancements.brightness = 10; 
                currentEnhancements.contrast = 10;
                currentEnhancements.greyscale = false; 
                currentEnhancements.bw = false;
                
                brightnessSlider.value = currentEnhancements.brightness;
                contrastSlider.value = currentEnhancements.contrast;
                sharpenBtn.style.backgroundColor = '#d4edda';
                greyscaleBtn.style.backgroundColor = '';
                bwBtn.style.backgroundColor = '';
                
                applyEnhancements();
            });

             // --- === END of V1 CLICK HANDLERS === ---


             // --- *** NEW: Delegated "Pickup Table" click listener *** ---
             dynamicInputArea.addEventListener('click', async (e) => {
                
                const clickedRow = e.target.closest('tr');
                if (!clickedRow) return; // Click was not on a row

                // --- Handle "Pick" button clicks ---
                if (e.target.classList.contains('pick-btn-dynamic')) {
                    if (isProcessingImage) return; // Check lock
                    
                    const pickButton = e.target;
                    const pickData = { ...pickButton.dataset }; 
                    const parentRow = pickButton.closest('tr');
                    
                    pickButton.disabled = true; 
                    pickButton.textContent = 'Picking...';
                    isProcessingImage = true; 

                    // 1. CHECK FOR IMAGE
                    if (!imagePreview.src || !imagePreview.src.startsWith('data:')) {
                        updateStatus("No image in preview. Capture or upload an image first.", true);
                        pickButton.disabled = false;
                        pickButton.textContent = 'Pick';
                        isProcessingImage = false; 
                        return;
                    }

                    // 2. GATHER DATA (V1 LOGIC)
                    let submitRowData = { // *** NEW: Build submit object here ***
                        uploadType: pickData.type || '', // *** FIX: No 'N/A' ***
                        refNumber: pickData.ref || '',
                        awbNumber: pickData.awb || '',
                        childAwb: '',
                        customerName: '',
                        customerUid: '',
                        kycNumber: '',
                        kycType: '',
                        docNumber: '',
                        docType: '',
                        statusRemark: '',
                        branch: selectedOrder?.BRANCH || '',
                        code: selectedOrder?.CODE || ''
                    };
                    
                    if (pickData.type === 'POD' || pickData.type === 'Reciept') {
                        const statusInput = parentRow.querySelector('.dynamic-text-input');
                        pickData.status = statusInput.value.trim() || (pickData.type === 'POD' ? 'Delivered' : 'Booked');
                        submitRowData.statusRemark = pickData.status;
                    } 
                    else if (pickData.type === 'KYC') {
                        const kycNumInput = parentRow.querySelector('.kyc-number-input');
                        const kycTypeSelect = parentRow.querySelector('.kyc-type-select');
                        pickData.kycNumber = kycNumInput ? kycNumInput.value.trim() : '';
                        pickData.kycType = kycTypeSelect ? kycTypeSelect.value : '';

                        if (!pickData.kycNumber) {
                            updateStatus("KYC Number is required.", true);
                            kycNumInput.focus();
                            pickButton.disabled = false;
                            pickButton.textContent = 'Pick';
                            isProcessingImage = false; 
                            return;
                        }
                        submitRowData.customerName = pickData.customerName || '';
                        submitRowData.customerUid = pickData.customerUid || '';
                        submitRowData.kycNumber = pickData.kycNumber;
                        submitRowData.kycType = pickData.kycType;
                    }
                    else if (pickData.type === 'Product') {
                        const remarkInput = parentRow.querySelector('.dynamic-text-input');
                        pickData.remark = remarkInput.value.trim() || 'PAPERS UPLOADED';
                        submitRowData.docNumber = pickData.docNumber || '';
                        submitRowData.docType = pickData.docType || '';
                        submitRowData.statusRemark = pickData.remark;
                    }
                    else if (pickData.type === 'MultiBox') {
                        const childAwbInput = parentRow.querySelector('.dynamic-text-input');
                        pickData.childAwb = childAwbInput.value.trim() || pickData.awb; 
                        submitRowData.childAwb = pickData.childAwb;
                    }
                    
                    console.log("Dynamic Pick clicked:", pickData);

                    try {
                        // 3. PROCESS IMAGE
                        updateStatus("Processing image... Please wait.");
                        const rotatedImageSrc = await getRotatedImage(imagePreview.src, currentRotation);
                        const finalImageSrc = await compressImage(rotatedImageSrc, 100, 1024);
                        
                        // 4. POPULATE TABLE
                        
                        // --- *** NEW BUNDLING LOGIC *** ---
                        let groupKey = null;
                        if (pickData.type === 'KYC') {
                            groupKey = `KYC_${submitRowData.refNumber}_${submitRowData.customerUid}`;
                        } else if (pickData.type === 'Product') {
                            groupKey = `PROD_${submitRowData.refNumber}_${submitRowData.docNumber}`;
                        } else if (pickData.type === 'MultiBox') {
                            groupKey = `MULTI_${submitRowData.awbNumber}`;
                        }
                        
                        let existingRow = groupKey ? Array.from(tableBody.rows).find(row => row.dataset.groupKey === groupKey) : null;

                        if (existingRow) {
                            // Add to existing bundle
                            let images = JSON.parse(existingRow.dataset.images);
                            images.push(finalImageSrc);
                            existingRow.dataset.images = JSON.stringify(images);
                            
                            // Update UI
                            existingRow.cells[0].textContent = `${pickData.type} (${images.length} images)`;
                            existingRow.cells[4].querySelector('img').src = finalImageSrc; // Show latest image
                            updateStatus(`Added image to ${pickData.type} bundle.`);
                            
                        } else {
                            // Create new row
                            const newRow = tableBody.insertRow();
                            newRow.dataset.keyRef = pickData.ref || pickData.awb || '';
                            newRow.dataset.keyType = pickData.type || '';
                            newRow.dataset.imageData = finalImageSrc; // Store for POD/Reciept
                            newRow.dataset.images = JSON.stringify([finalImageSrc]); // Store for bundling
                            newRow.dataset.submitData = JSON.stringify(submitRowData);
                            if (groupKey) {
                                newRow.dataset.groupKey = groupKey;
                            }

                            const rowData = {
                                type: pickData.type || 'N/A',
                                status: pickData.status || submitRowData.statusRemark || '', // *** FIX: No 'N/A' ***
                                refAwb: (pickData.type === 'MultiBox')
                                    ? `Ref: ${pickData.ref || ''} <br> Child: ${pickData.childAwb}`
                                    : `Ref: ${pickData.ref || ''} <br> AWB: ${pickData.awb || ''}`,
                                customerKyc: pickData.type === 'KYC' 
                                    ? `Cust: ${pickData.customerName || ''} <br> UID: ${pickData.customerUid || ''} <br> KYC: ${pickData.kycNumber} (${pickData.kycType})`
                                    : '', // *** FIX: No 'N/A' ***
                                docInfo: pickData.type === 'Product'
                                    ? `Doc: ${pickData.docNumber || ''} <br> Type: ${pickData.docType || ''} <br> Remark: ${pickData.remark}`
                                    : '', // *** FIX: No 'N/A' ***
                                image: finalImageSrc
                            };
                            
                            // Update count display for bundles
                            let statusText = `${rowData.type} - ${rowData.status}`;
                            if(groupKey) statusText = `${rowData.type} (1 image)`;

                            newRow.insertCell().textContent = statusText;
                            newRow.insertCell().innerHTML = rowData.refAwb;
                            newRow.insertCell().innerHTML = rowData.customerKyc || 'N/A';
                            newRow.insertCell().innerHTML = rowData.docInfo || 'N/A';
                            
                            const imageCell = newRow.insertCell();
                            const thumb = document.createElement('img');
                            thumb.src = rowData.image;
                            const cellDiv = document.createElement('div');
                            cellDiv.className = 'image-cell-content';
                            cellDiv.appendChild(thumb);
                            imageCell.appendChild(cellDiv);
                            
                            const hiddenCell = newRow.insertCell();
                            hiddenCell.textContent = `Branch: ${submitRowData.branch}, Code: ${submitRowData.code}`;
                            hiddenCell.style.display = 'none';

                            updateStatus(`Added ${pickData.type} for ${pickData.ref} to table.`);
                        }
                        
                        // --- *** END BUNDLING LOGIC *** ---
                        
                        // --- *** NEW: Reset inputs in the picked row *** ---
                        const inputsToClear = parentRow.querySelectorAll('input[type="text"], .kyc-number-input');
                        inputsToClear.forEach(input => {
                            input.value = ''; // Clear the value
                        });
                        // Reset dropdown to first option
                        const selectsToClear = parentRow.querySelectorAll('select');
                        selectsToClear.forEach(select => {
                            select.selectedIndex = 0;
                        });

                        // *** NEW: Deselect the pickup row ***
                        if (selectedPickupRow) {
                            selectedPickupRow.classList.remove('selected-pickup-row');
                            selectedPickupRow = null;
                        }
                        
                        // *** NEW: Re-render the pickup table to hide the picked row ***
                        // This will also trigger the new "POD complete" check
                        renderDynamicInputs();
                        
                        // 5. RESET
                        if (!isImageLocked) {
                            if (imageQueue.length > 0) {
                                imageQueue.splice(currentImageIndex, 1);
                                renderScroller();
                                isProcessingImage = false; 
                                displayImage(currentImageIndex < imageQueue.length ? currentImageIndex : 0);
                            } else {
                                resetUploader(); 
                            }
                        } else {
                             isProcessingImage = false; 
                        }

                    } catch (err) {
                        console.error("Failed during pick process:", err);
                        updateStatus("Error processing image.", true);
                        isProcessingImage = false; // Release lock on error
                    } finally {
                        if (pickButton) { 
                            pickButton.disabled = false;
                            pickButton.textContent = 'Pick';
                        }
                    }
                }
                
                // --- Handle Row Selection ---
                else {
                    if (selectedPickupRow) {
                        selectedPickupRow.classList.remove('selected-pickup-row');
                    }
                    selectedPickupRow = clickedRow;
                    selectedPickupRow.classList.add('selected-pickup-row');
                }
             });
             
             
             // --- *** NEW: Table Action Button Listeners *** ---
             deleteLastBtn.addEventListener('click', () => {
                if (tableBody.rows.length > 0) {
                    tableBody.deleteRow(-1);
                    updateStatus("Last entry deleted.");
                    // Re-render pickup table to show the task again
                    if (selectedOrder) {
                        renderDynamicInputs();
                    }
                    resetUploader(); // *** NEW: Clear image cache ***
                }
             });

             clearAllBtn.addEventListener('click', () => {
                if (tableBody.rows.length > 0) {
                    tableBody.innerHTML = '';
                    updateStatus("All entries cleared.");
                    // Re-render pickup table to show all tasks again
                    if (selectedOrder) {
                        renderDynamicInputs();
                    }
                    resetUploader(); // *** NEW: Clear image cache ***
                }
             });
             
             submitBtn.addEventListener('click', async () => {
                if (isProcessingImage) {
                    updateStatus("Please wait for image processing to finish.", true);
                    return;
                }
                const rows = tableBody.rows;
                const gscriptUrl = gscriptUrlInput.value.trim();
                
                if (rows.length === 0) {
                    updateStatus("No data in the table to submit.", true); return;
                }
                if (!gscriptUrl || !gscriptUrl.startsWith('https://script.google.com/macros/s/')) {
                    updateStatus("Please provide a valid Google Apps Script Web App URL.", true);
                    return;
                }
                
                // Get Auth Credentials from localStorage (V1 Logic)
                let authCode = '', authToken = '', authUser = '';
                const loginDataJSON = localStorage.getItem('loginData');
                if (!loginDataJSON) {
                    updateStatus("Authentication error: loginData not found. Please re-login.", true);
                    return;
                }
                try {
                    const loginData = JSON.parse(loginDataJSON);
                    authCode = loginData.CODE;
                    authToken = loginData.TOKEN;
                    authUser = loginData.USER; // Or NAME, adjust as needed
                } catch (e) {
                     updateStatus("Authentication error: Could not parse loginData. Please re-login.", true);
                     return;
                }

                submitBtn.disabled = true;
                let successCount = 0;
                let failedRows = [];

                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    // Skip rows that are already green (successfully submitted)
                    if (row.style.backgroundColor === 'rgb(212, 237, 218)') { // 'd4edda'
                        successCount++;
                        continue;
                    }
                    
                    updateStatus(`Submitting row ${i + 1} of ${rows.length}...`);
                    
                    // Retrieve stored data
                    const rowData = JSON.parse(row.dataset.submitData);
                    const images = JSON.parse(row.dataset.images);
                    let finalImageData;
                    let fileName;

                    // --- *** NEW PDF BUNDLING LOGIC *** ---
                    if (rowData.uploadType === 'POD' || rowData.uploadType === 'Reciept') {
                        finalImageData = images[0]; // Just the single base64 image
                        fileName = `${rowData.refNumber || rowData.awbNumber}-${Date.now()}.jpg`;
                    } else {
                        // Bundle multiple images into a PDF
                        updateStatus(`Bundling ${images.length} images into PDF for ${rowData.uploadType}...`);
                        finalImageData = await createPdfFromImages(images);
                        
                        if (rowData.uploadType === 'KYC') {
                            fileName = `${rowData.refNumber}-${rowData.customerUid}-${rowData.kycNumber}.pdf`;
                        } else if (rowData.uploadType === 'Product') {
                            fileName = `${rowData.refNumber}-${rowData.docNumber}.pdf`;
                        } else if (rowData.uploadType === 'MultiBox') {
                            fileName = `${rowData.awbNumber}-multibox.pdf`;
                        } else {
                            fileName = `${rowData.refNumber || rowData.awbNumber}-${Date.now()}.pdf`;
                        }
                    }
                    // --- *** END PDF BUNDLING LOGIC *** ---

                    const payload = {
                        code: authCode,
                        token: authToken,
                        user: authUser, // Sending user
                        action: 'append',
                        imageData: finalImageData, // This is now either base64 img or base64 pdf
                        fileName: fileName,
                        rowData: rowData,
                    };
                    
                    try {
                        const response = await fetch(gscriptUrl, {
                            method: 'POST',
                            body: JSON.stringify(payload),
                            headers: { 'Content-Type': 'text/plain;charset=utf-8' }, // V1 used text/plain
                            mode: 'cors',
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Network error: ${response.status} ${response.statusText}`);
                        }

                        const result = await response.json();
                        
                        if (result.status === 'success') {
                            successCount++;
                            row.style.backgroundColor = '#d4edda'; // Green
                        } else {
                            throw new Error(result.message || 'Unknown error from server.');
                        }
                    } catch (error) {
                        console.error('Submission error:', error);
                        row.style.backgroundColor = '#f8d7da'; // Red
                        failedRows.push(i + 1);
                        updateStatus(`Error submitting row ${i + 1}: ${error.message}`, true);
                    }
                } // End for loop
                
                submitBtn.disabled = false;
                if (failedRows.length > 0) {
                    updateStatus(`Failed to submit rows: ${failedRows.join(', ')}. Please fix and retry.`, true);
                } else {
                    updateStatus(`Successfully submitted all ${successCount} rows.`, false);
                    setTimeout(() => {
                        clearAllBtn.click(); // Clear the table (and resetUploader)
                        updateStatus('All data submitted and table cleared.');
                    }, 2000);
                }
             });
             

             // --- Barcode Detector Init ---
            if (!('BarcodeDetector' in window)) {
                console.log('Barcode Detector is not supported by this browser.');
            } else {
                console.log('Barcode Detector supported!');
                try {
                    barcodeDetector = new BarcodeDetector({
                        formats: ['code_128', 'code_39', 'ean_13', 'qr_code', 'upc_a', 'itf']
                    });
                } catch (e) {
                    console.error('Barcode Detector could not be instantiated.', e);
                }
            }
        });
    </script>
</body>
</html>
