<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uploader with Barcode & OCR</title>
    <!-- Cropper.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
    <style>
        body {
            display: flex; justify-content: center; align-items: center; min-height: 100vh;
            margin: 0; padding: 20px 0; background-color: #f9f9f9; font-family: sans-serif; flex-direction: column;
        }
        .uploader-container {
            display: flex; flex-direction: column; align-items: center; gap: 15px;
            width: 100%; max-width: 800px; padding: 0 15px; box-sizing: border-box;
        }
        /* Scroller Styles */
        #image-scroller-container {
            width: 100%; height: 80px; background-color: #eee; border: 1px solid #ddd;
            border-radius: 4px; padding: 5px; box-sizing: border-box; display: none;
        }
        #image-scroller {
            height: 100%; display: flex; gap: 5px; overflow-x: auto; white-space: nowrap;
        }
        .scroller-img {
            height: 100%; width: 70px; object-fit: cover; cursor: pointer;
            border: 2px solid transparent; border-radius: 2px; transition: border-color 0.2s;
        }
        .scroller-img.active { border-color: #007bff; }
        
        #image-view-area {
            border: 2px dashed #ccc; width: 100%; aspect-ratio: 4 / 3; display: flex;
            justify-content: center; align-items: center; text-align: center; color: #888;
            position: relative; overflow: hidden; background-color: #f0f0f0;
            cursor: default;
        }
        #image-view-area.selectable {
            cursor: crosshair;
        }
        /* Hide the original image, we will draw it on the canvas */
        #image-preview { 
            display: none;
        }
        #camera-feed, #preview-canvas {
            width: 100%; height: 100%; object-fit: contain;
        }
        #preview-canvas { display: none; }

        .button-group { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        button {
            padding: 8px 16px; border: 1px solid #ccc; background-color: #fff; border-radius: 4px; cursor: pointer;
        }
        #rotate-btn, #lock-btn, #cancel-btn, #cancel-all-btn, #file-input { display: none; }
        .entry-input-group { display: flex; flex-wrap: wrap; gap: 8px; width: 100%; align-items: center; }
        .entry-input-group input { padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; }
        
        /* Table Styles */
        .data-table-container { width: 100%; margin-top: 5px; overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; font-size: 14px; }
        th { background-color: #f0f0f0; }
        td .image-cell-content { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; }
        td .image-cell-content img { max-width: 100%; max-height: 100%; object-fit: contain; }
        #table-actions { width: 100%; margin-top: 15px; }

        /* Inline Cropper Styles */
        #inline-cropper-wrapper {
            display: none; /* Hidden by default */
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            background-color: #f0f0f0;
            border: 2px dashed #007bff; 
        }
        #cropper-container {
            width: 100%;
            height: 60vh;
        }
        #cropper-image {
            display: block;
            max-width: 100%;
        }
        
        /* OCR Selection Canvas */
        #selection-canvas {
            position: absolute;
            top: 0; left: 0;
            display: none; /* Hidden by default */
            z-index: 10;
        }
        
        /* Status Bar */
        #status-bar {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            min-height: 2.5em;
            text-align: center;
            background-color: #e9ecef;
            border-radius: 4px;
            color: #495057;
        }
        #status-bar.error {
            color: #dc3545;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="uploader-container">
        <!-- Buttons -->
        <div class="button-group">
            <button id="camera-btn">Camera</button>
            <button id="upload-btn">Upload</button>
            <button id="rotate-btn">Rotate</button>
            <button id="lock-btn">Lock</button>
            <button id="cancel-btn">Cancel</button>
            <button id="cancel-all-btn">Cancel All</button>
            <input type="file" id="file-input" accept="image/*" multiple>
        </div>
        <!-- Scroller -->
        <div id="image-scroller-container"><div id="image-scroller"></div></div>
        
        <!-- Inline Cropper -->
        <div id="inline-cropper-wrapper">
            <div id="cropper-container">
                <img id="cropper-image" src="">
            </div>
            <div class="button-group" style="margin-top: 10px;">
                <button id="crop-rotate-btn">Rotate</button>
                <button id="crop-confirm-btn">Crop</button>
                <button id="crop-cancel-btn">Cancel</button>
            </div>
        </div>

        <!-- Preview Area -->
        <div id="image-view-area">
            <span id="placeholder">Image preview area</span>
            <img id="image-preview" src="" alt="Image preview"/>
            <canvas id="preview-canvas"></canvas>
            <canvas id="selection-canvas"></canvas>
            <video id="camera-feed" autoplay playsinline></video>
        </div>
        
        <!-- Status Bar -->
        <div id="status-bar"></div>

        <!-- Inputs -->
        <div class="entry-input-group">
            <input type="text" id="awb-input" placeholder="Enter AWB / Ref (Required)">
            <input type="text" id="remark-input" placeholder="Enter Status Remark (Optional)">
            <button id="pick-btn">Pick</button>
        </div>
        <!-- Table -->
        <div class="data-table-container">
            <table>
                <thead><tr><th>Sl No</th><th>AWB / Ref</th><th>Status Remark</th><th>Image</th></tr></thead>
                <tbody id="data-table-body"></tbody>
            </table>
        </div>
        <!-- Table Actions -->
        <div class="button-group" id="table-actions">
            <button id="delete-last-btn">Delete Last</button>
            <button id="clear-all-btn">Clear All</button>
            <button id="submit-btn">Submit</button>
        </div>
    </div>
    
    <!-- Third-party libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>

    <script>
        // DOM Elements
        const cameraBtn = document.getElementById('camera-btn'), uploadBtn = document.getElementById('upload-btn'),
              fileInput = document.getElementById('file-input'), placeholder = document.getElementById('placeholder'),
              imagePreview = document.getElementById('image-preview'), cameraFeed = document.getElementById('camera-feed'),
              previewCanvas = document.getElementById('preview-canvas'),
              rotateBtn = document.getElementById('rotate-btn'), lockBtn = document.getElementById('lock-btn'),
              cancelBtn = document.getElementById('cancel-btn'), cancelAllBtn = document.getElementById('cancel-all-btn'),
              pickBtn = document.getElementById('pick-btn'), tableBody = document.getElementById('data-table-body'),
              awbInput = document.getElementById('awb-input'), remarkInput = document.getElementById('remark-input'),
              deleteLastBtn = document.getElementById('delete-last-btn'), clearAllBtn = document.getElementById('clear-all-btn'),
              submitBtn = document.getElementById('submit-btn'), scrollerContainer = document.getElementById('image-scroller-container'),
              scroller = document.getElementById('image-scroller'), 
              inlineCropperWrapper = document.getElementById('inline-cropper-wrapper'),
              imageViewArea = document.getElementById('image-view-area'),
              cropperImage = document.getElementById('cropper-image'), cropConfirmBtn = document.getElementById('crop-confirm-btn'),
              cropCancelBtn = document.getElementById('crop-cancel-btn'),
              cropRotateBtn = document.getElementById('crop-rotate-btn'),
              selectionCanvas = document.getElementById('selection-canvas'),
              statusBar = document.getElementById('status-bar');


        // State Variables
        let stream = null, currentRotation = 0, isImageLocked = false, cropper = null;
        let imageQueue = [], currentImageIndex = -1;
        let barcodeDetector;
        const MAX_FILES = 50, MAX_ROWS = 20;

        // OCR Selection State
        let isSelecting = false, selectionRect = {};
        const selectionCtx = selectionCanvas.getContext('2d');
        const previewCtx = previewCanvas.getContext('2d');


        // --- Barcode Detector Initialization ---
        if (!('BarcodeDetector' in window)) {
            console.log('Barcode Detector is not supported by this browser.');
        } else {
            console.log('Barcode Detector supported!');
            try {
                barcodeDetector = new BarcodeDetector({
                    formats: ['code_128', 'code_39', 'ean_13', 'qr_code', 'upc_a', 'itf']
                });
            } catch (e) {
                console.error('Barcode Detector could not be instantiated.', e);
            }
        }
        
        // --- Status Update Logic ---
        function updateStatus(message, isError = false) {
            statusBar.textContent = message;
            statusBar.classList.toggle('error', isError);
        }

        // --- Scanning Logic ---
        async function scanBarcodeFromPreview() {
            if (!barcodeDetector) {
                updateStatus("Barcode detection not supported. Select area for OCR.", true);
                return;
            }
            if (!imagePreview.src || !imagePreview.src.startsWith('data:')) return;

            try {
                updateStatus("Attempting barcode scan...");
                const barcodes = await barcodeDetector.detect(imagePreview); // Scan original, un-rotated image
                if (barcodes.length > 0) {
                    const barcodeValue = barcodes[0].rawValue;
                    awbInput.value = barcodeValue;
                    updateStatus(`Barcode detected: ${barcodeValue}`);
                } else {
                    updateStatus("No barcode found. Please select an area for OCR.");
                }
            } catch (err) {
                console.error("Barcode scan failed:", err);
                updateStatus("Barcode scan failed. Select area for OCR.", true);
            }
        }

        // --- Main App Logic ---
        function setInterfaceState(state) {
            cameraBtn.style.display='inline-block'; uploadBtn.style.display='inline-block';
            rotateBtn.style.display='none'; lockBtn.style.display='none';
            cancelBtn.style.display='none'; cancelAllBtn.style.display='none';
            imageViewArea.classList.remove('selectable');

            if (state === 'streaming') {
                cameraBtn.textContent = 'Capture'; uploadBtn.style.display = 'none'; cancelBtn.style.display = 'inline-block';
                previewCanvas.style.display = 'none';
                cameraFeed.style.display = 'block';
            } else if (state === 'preview') {
                cameraBtn.style.display='none'; uploadBtn.style.display='none';
                rotateBtn.style.display='inline-block'; lockBtn.style.display='inline-block';
                imageViewArea.classList.add('selectable');
                if(imageQueue.length > 0) {
                    cancelBtn.style.display='inline-block'; cancelAllBtn.style.display='inline-block';
                } else {
                    cancelBtn.style.display='inline-block';
                }
            }
        }

        function resetUploader() {
            stopCamera();
            placeholder.style.display = 'block';
            previewCanvas.style.display = 'none';
            cameraFeed.style.display = 'none'; 
            imagePreview.src = ''; // Clear image source
            fileInput.value = ''; currentRotation = 0;
            isImageLocked = false; lockBtn.textContent = 'Lock'; lockBtn.style.backgroundColor = '';
            imageQueue = []; currentImageIndex = -1;
            scroller.innerHTML = ''; scrollerContainer.style.display = 'none';
            
            inlineCropperWrapper.style.display = 'none';
            imageViewArea.style.display = 'flex';
            selectionCanvas.style.display = 'none';
            updateStatus('');

            setInterfaceState('idle');
        }

        function stopCamera() { if (stream) { stream.getTracks().forEach(track => track.stop()); stream = null; } }

        function displayImage(index) {
            if (index < 0 || index >= imageQueue.length) { resetUploader(); return; }
            currentImageIndex = index;
            const file = imageQueue[index];
            const reader = new FileReader();
            reader.onload = (e) => initCropper(e.target.result, file.name);
            reader.readAsDataURL(file);
        }

        function renderScroller() {
            scroller.innerHTML = '';
            imageQueue.forEach((file, index) => {
                const thumb = document.createElement('img');
                try { thumb.src = URL.createObjectURL(file); } catch(e) { console.error("Could not create object URL for", file); }
                thumb.className = 'scroller-img'; thumb.dataset.index = index;
                thumb.onclick = () => displayImage(index);
                scroller.appendChild(thumb);
            });
            updateActiveThumbnail();
        }

        function updateActiveThumbnail() {
            document.querySelectorAll('.scroller-img').forEach((img, index) => {
                img.classList.toggle('active', index === currentImageIndex);
            });
        }
        
        // --- Cropper Logic ---
        function initCropper(imageSrc, originalFileName) {
            inlineCropperWrapper.style.display = 'block';
            imageViewArea.style.display = 'none';
            scrollerContainer.style.display = 'none'; 

            cropperImage.src = imageSrc;
            if (cropper) cropper.destroy();
            cropper = new Cropper(cropperImage, {
                viewMode: 1, // Allow freeform cropping
                background: false,
            });
            
            const confirmCropHandler = async () => {
                const croppedCanvas = cropper.getCroppedCanvas({
                    minWidth: 256,
                    minHeight: 256,
                    maxWidth: 4096,
                    maxHeight: 4096,
                    fillColor: '#fff',
                    imageSmoothingEnabled: true,
                    imageSmoothingQuality: 'high',
                });
                if (!croppedCanvas) { return; }
                const croppedDataUrl = croppedCanvas.toDataURL('image/png');
                
                inlineCropperWrapper.style.display = 'none';
                imageViewArea.style.display = 'flex';
                if (imageQueue.length > 1) scrollerContainer.style.display = 'block';

                imagePreview.onload = () => {
                    drawPreview();
                    scanBarcodeFromPreview();
                    imagePreview.onload = null;
                };
                imagePreview.src = croppedDataUrl; 

                placeholder.style.display = 'none';
                cameraFeed.style.display = 'none';
                previewCanvas.style.display = 'block';
                currentRotation = 0;

                if (currentImageIndex !== -1) {
                    const newFile = await dataURLtoFile(croppedDataUrl, originalFileName);
                    imageQueue[currentImageIndex] = newFile;
                    renderScroller();
                }

                setInterfaceState('preview');
                cropConfirmBtn.removeEventListener('click', confirmCropHandler);
            };
            cropConfirmBtn.addEventListener('click', confirmCropHandler, { once: true });
        }
        
        cropCancelBtn.addEventListener('click', () => {
            inlineCropperWrapper.style.display = 'none';
            imageViewArea.style.display = 'flex';
            if (imageQueue.length > 1) scrollerContainer.style.display = 'block';
            if (cropper) cropper.destroy();
            if (!imagePreview.src) {
                resetUploader();
            }
        });
        
        cropRotateBtn.addEventListener('click', () => {
            if (cropper) {
                cropper.rotate(90);
            }
        });

        function drawPreview() {
            if (!imagePreview.src) return;
            const dpr = window.devicePixelRatio || 1;
            const containerW = imageViewArea.clientWidth;
            const containerH = imageViewArea.clientHeight;
            
            previewCanvas.width = containerW * dpr;
            previewCanvas.height = containerH * dpr;
            previewCanvas.style.width = `${containerW}px`;
            previewCanvas.style.height = `${containerH}px`;
            
            previewCtx.scale(dpr, dpr);
            
            const naturalW = imagePreview.naturalWidth;
            const naturalH = imagePreview.naturalHeight;
            const imgAspect = naturalW / naturalH;
            const contAspect = containerW / containerH;
            let renderedW, renderedH;

            if (imgAspect > contAspect) {
                renderedW = containerW; renderedH = containerW / imgAspect;
            } else {
                renderedH = containerH; renderedW = containerH * imgAspect;
            }
            
            previewCtx.clearRect(0, 0, containerW, containerH);
            previewCtx.save();
            previewCtx.translate(containerW / 2, containerH / 2);
            previewCtx.rotate(currentRotation * Math.PI / 180);
            previewCtx.drawImage(imagePreview, -renderedW / 2, -renderedH / 2, renderedW, renderedH);
            previewCtx.restore();
        }

        // --- Event Listeners ---
        cameraBtn.addEventListener('click', async () => {
            if (stream) {
                const canvas = document.createElement('canvas');
                canvas.width = cameraFeed.videoWidth; canvas.height = cameraFeed.videoHeight;
                canvas.getContext('2d').drawImage(cameraFeed, 0, 0);
                const dataUrl = canvas.toDataURL('image/png');
                stopCamera();
                imageQueue = []; currentImageIndex = -1; scrollerContainer.style.display = 'none';
                initCropper(dataUrl, `capture-${Date.now()}.png`);
            } else {
                resetUploader();
                const constraints = { video: { facingMode: { exact: "environment" } } };
                try { stream = await navigator.mediaDevices.getUserMedia(constraints); } 
                catch { try { stream = await navigator.mediaDevices.getUserMedia({ video: true }); } catch (e) { updateStatus("Could not access camera.", true); return; } }
                placeholder.style.display = 'none';
                cameraFeed.style.display = 'block';
                cameraFeed.srcObject = stream; cameraFeed.play(); 
                setInterfaceState('streaming');
            }
        });

        uploadBtn.addEventListener('click', () => { resetUploader(); fileInput.click(); });
        
        fileInput.addEventListener('change', (event) => {
            const files = Array.from(event.target.files).slice(0, MAX_FILES);
            if (files.length === 0) return;
            imageQueue = files;
            scrollerContainer.style.display = imageQueue.length > 1 ? 'block' : 'none';
            if (imageQueue.length > 1) renderScroller();
            displayImage(0);
        });

        rotateBtn.addEventListener('click', () => {
            if (previewCanvas.style.display === 'block') {
                currentRotation = (currentRotation + 90) % 360;
                drawPreview();
            }
        });
        
        lockBtn.addEventListener('click', () => {
            isImageLocked = !isImageLocked;
            lockBtn.textContent = isImageLocked ? 'Unlock' : 'Lock';
            lockBtn.style.backgroundColor = isImageLocked ? '#d4edda' : '';
        });

        cancelBtn.addEventListener('click', () => {
            if (isImageLocked) { resetUploader(); return; }
            if (imageQueue.length > 0) {
                 imageQueue.splice(currentImageIndex, 1);
                 renderScroller();
                 displayImage(currentImageIndex < imageQueue.length ? currentImageIndex : 0);
            } else { resetUploader(); }
        });
        
        cancelAllBtn.addEventListener('click', resetUploader);
        
        // --- OCR Area Selection Listeners ---
        imageViewArea.addEventListener('mousedown', (e) => {
            if (previewCanvas.style.display !== 'block' || isSelecting) return;
            e.preventDefault();
            
            const rect = imageViewArea.getBoundingClientRect();
            selectionCanvas.width = rect.width;
            selectionCanvas.height = rect.height;
            selectionCanvas.style.display = 'block';

            isSelecting = true;
            selectionRect.startX = e.clientX - rect.left;
            selectionRect.startY = e.clientY - rect.top;

            window.addEventListener('mousemove', onSelectionMove);
            window.addEventListener('mouseup', onSelectionUp, { once: true });
        });

        function onSelectionMove(e) {
            if (!isSelecting) return;
            const rect = imageViewArea.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            const width = currentX - selectionRect.startX;
            const height = currentY - selectionRect.startY;

            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            selectionCtx.strokeStyle = 'red';
            selectionCtx.lineWidth = 2;
            selectionCtx.strokeRect(selectionRect.startX, selectionRect.startY, width, height);
        }

        async function onSelectionUp(e) {
            isSelecting = false;
            window.removeEventListener('mousemove', onSelectionMove);
            
            selectionCanvas.style.display = 'none';
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            
            const rect = imageViewArea.getBoundingClientRect();
            const selectionEndX = e.clientX - rect.left;
            const selectionEndY = e.clientY - rect.top;

            const dpr = window.devicePixelRatio || 1;
            const selRect = {
                x: Math.min(selectionRect.startX, selectionEndX) * dpr,
                y: Math.min(selectionRect.startY, selectionEndY) * dpr,
                width: Math.abs(selectionRect.startX - selectionEndX) * dpr,
                height: Math.abs(selectionRect.startY - selectionEndY) * dpr,
            };

            if (selRect.width < 10 || selRect.height < 10) return;
            
            const cropCanvas = document.createElement('canvas');
            const cropCtx = cropCanvas.getContext('2d');
            cropCanvas.width = selRect.width;
            cropCanvas.height = selRect.height;
            
            cropCtx.drawImage(previewCanvas, selRect.x, selRect.y, selRect.width, selRect.height, 0, 0, selRect.width, selRect.height);
            
            updateStatus("Running OCR on selected area...");
            try {
                const { data: { text } } = await Tesseract.recognize(cropCanvas, 'eng');
                const ocrText = text.trim().replace(/\s+/g, ' ');
                if (ocrText) {
                    awbInput.value = ocrText;
                    updateStatus(`OCR successful: "${ocrText}"`);
                } else {
                    updateStatus("OCR could not find any text.");
                }
            } catch (err) {
                updateStatus("OCR failed on selection.", true);
            }
        }

        pickBtn.addEventListener('click', async () => {
            if (!imagePreview.src) { 
                updateStatus("No image to pick.", true); 
                return; 
            }
            const awbValue = awbInput.value.trim();
            if (awbValue === '') { 
                updateStatus("Please enter AWB / Ref.", true); 
                awbInput.focus(); 
                return; 
            }
            if (tableBody.rows.length >= MAX_ROWS) { 
                updateStatus("Table is full.", true); 
                return; 
            }

            const rotatedImageSrc = await getRotatedImage(imagePreview.src, currentRotation);
            const newRow = tableBody.insertRow();
            newRow.insertCell(0).textContent = tableBody.rows.length;
            newRow.insertCell(1).textContent = awbValue;
            newRow.insertCell(2).textContent = remarkInput.value.trim();
            const thumb = document.createElement('img'); thumb.src = rotatedImageSrc;
            const cellDiv = document.createElement('div'); cellDiv.className = 'image-cell-content';
            cellDiv.appendChild(thumb);
            newRow.insertCell(3).appendChild(cellDiv);
            
            awbInput.value = ''; remarkInput.value = '';
            
            if (!isImageLocked) {
                if (imageQueue.length > 0) {
                    imageQueue.splice(currentImageIndex, 1);
                    renderScroller();
                    displayImage(currentImageIndex < imageQueue.length ? currentImageIndex : 0);
                } else { resetUploader(); }
            } else { awbInput.focus(); }
        });
        
        // --- Table & Utility Functions ---
        deleteLastBtn.addEventListener('click', () => { if (tableBody.rows.length > 0) tableBody.deleteRow(-1); });
        clearAllBtn.addEventListener('click', () => { tableBody.innerHTML = ''; });
        submitBtn.addEventListener('click', () => { updateStatus("Submit functionality not yet implemented."); });

        async function dataURLtoFile(dataUrl, fileName) {
            const res = await fetch(dataUrl); const blob = await res.blob();
            return new File([blob], fileName, { type: blob.type || 'image/png' });
        }
        
        function getRotatedImage(src, rotation) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d'), angle = rotation * Math.PI / 180;
                    if (rotation % 180 !== 0) { canvas.width = img.height; canvas.height = img.width; } 
                    else { canvas.width = img.width; canvas.height = img.height; }
                    ctx.translate(canvas.width / 2, canvas.height / 2); ctx.rotate(angle);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    resolve(canvas.toDataURL());
                };
                img.src = src;
            });
        }
        
        resetUploader();
    </script>
</body>
</html>

